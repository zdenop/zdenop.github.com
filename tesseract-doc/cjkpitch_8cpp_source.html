<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Tesseract: tesseract-ocr/textord/cjkpitch.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tesseract
   &#160;<span id="projectnumber">3.02</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('cjkpitch_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tesseract-ocr/textord/cjkpitch.cpp</div>  </div>
</div>
<div class="contents">
<a href="cjkpitch_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">// File:        cjkpitch.cpp</span>
<a name="l00003"></a>00003 <span class="comment">// Description: Code to determine fixed pitchness and the pitch if fixed,</span>
<a name="l00004"></a>00004 <span class="comment">//              for CJK text.</span>
<a name="l00005"></a>00005 <span class="comment">// Copyright 2011 Google Inc. All Rights Reserved.</span>
<a name="l00006"></a>00006 <span class="comment">// Author: takenaka@google.com (Hiroshi Takenaka)</span>
<a name="l00007"></a>00007 <span class="comment">// Created:     Mon Jun 27 12:48:35 JST 2011</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<a name="l00010"></a>00010 <span class="comment">// you may not use this file except in compliance with the License.</span>
<a name="l00011"></a>00011 <span class="comment">// You may obtain a copy of the License at</span>
<a name="l00012"></a>00012 <span class="comment">// http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00013"></a>00013 <span class="comment">// Unless required by applicable law or agreed to in writing, software</span>
<a name="l00014"></a>00014 <span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<a name="l00015"></a>00015 <span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<a name="l00016"></a>00016 <span class="comment">// See the License for the specific language governing permissions and</span>
<a name="l00017"></a>00017 <span class="comment">// limitations under the License.</span>
<a name="l00018"></a>00018 <span class="comment">//</span>
<a name="l00020"></a>00020 <span class="comment"></span><span class="preprocessor">#include &quot;<a class="code" href="cjkpitch_8h.html">cjkpitch.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="genericvector_8h.html">genericvector.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="ndminx_8h.html">ndminx.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="topitch_8h.html">topitch.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="tovars_8h.html">tovars.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <a class="code" href="params_8h.html#a442e7f541a050acf5ebda026db177877">BOOL_VAR</a>(<a class="code" href="cjkpitch_8cpp.html#ae487cd6731bb3f5515eced4c24adf033">textord_space_size_is_variable</a>, <a class="code" href="host_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>,
<a name="l00027"></a>00027          <span class="stringliteral">&quot;If true, word delimiter spaces are assumed to have &quot;</span>
<a name="l00028"></a><a class="code" href="cjkpitch_8cpp.html#ae487cd6731bb3f5515eced4c24adf033">00028</a>          <span class="stringliteral">&quot;variable width, even though characters have fixed pitch.&quot;</span>);
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="keyword">namespace </span>{
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">// Allow +/-10% error for character pitch / body size.</span>
<a name="l00033"></a>00033 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> kFPTolerance = 0.1;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">// Minimum ratio of &quot;good&quot; character pitch for a row to be considered</span>
<a name="l00036"></a>00036 <span class="comment">// to be fixed-pitch.</span>
<a name="l00037"></a>00037 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> kFixedPitchThreshold = 0.35;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="comment">// rank statistics for a small collection of float values.</span>
<a name="l00040"></a>00040 <span class="keyword">class </span>SimpleStats {
<a name="l00041"></a>00041  <span class="keyword">public</span>:
<a name="l00042"></a>00042   SimpleStats(): finalized_(false), values_() { }
<a name="l00043"></a>00043   ~SimpleStats() { }
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   <span class="keywordtype">void</span> Clear() {
<a name="l00046"></a>00046     values_.clear();
<a name="l00047"></a>00047     finalized_ = <span class="keyword">false</span>;
<a name="l00048"></a>00048   }
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="keywordtype">void</span> Add(<span class="keywordtype">float</span> value) {
<a name="l00051"></a>00051     values_.push_back(value);
<a name="l00052"></a>00052     finalized_ = <span class="keyword">false</span>;
<a name="l00053"></a>00053   }
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   <span class="keywordtype">void</span> Finish() {
<a name="l00056"></a>00056     values_.sort(float_compare);
<a name="l00057"></a>00057     finalized_ = <span class="keyword">true</span>;
<a name="l00058"></a>00058   }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="keywordtype">float</span> ile(<span class="keywordtype">double</span> frac) {
<a name="l00061"></a>00061     <span class="keywordflow">if</span> (!finalized_) Finish();
<a name="l00062"></a>00062     <span class="keywordflow">if</span> (values_.empty()) <span class="keywordflow">return</span> 0.0;
<a name="l00063"></a>00063     <span class="keywordflow">if</span> (frac &gt;= 1.0) <span class="keywordflow">return</span> values_.back();
<a name="l00064"></a>00064     <span class="keywordflow">if</span> (frac &lt;= 0.0 || values_.size() == 1) <span class="keywordflow">return</span> values_[0];
<a name="l00065"></a>00065     <span class="keywordtype">int</span> index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>((values_.size() - 1) * frac);
<a name="l00066"></a>00066     <span class="keywordtype">float</span> reminder = (values_.size() - 1) * frac - index;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068     <span class="keywordflow">return</span> values_[index] * (1.0 - reminder) +
<a name="l00069"></a>00069         values_[index + 1] * reminder;
<a name="l00070"></a>00070   }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="keywordtype">float</span> median() {
<a name="l00073"></a>00073     <span class="keywordflow">return</span> ile(0.5);
<a name="l00074"></a>00074   }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="keywordtype">float</span> maximum() {
<a name="l00077"></a>00077     <span class="keywordflow">if</span> (!finalized_) Finish();
<a name="l00078"></a>00078     <span class="keywordflow">if</span> (values_.empty()) <span class="keywordflow">return</span> 0.0;
<a name="l00079"></a>00079     <span class="keywordflow">return</span> values_.back();
<a name="l00080"></a>00080   }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   <span class="keywordtype">float</span> minimum() {
<a name="l00083"></a>00083     <span class="keywordflow">if</span> (!finalized_) Finish();
<a name="l00084"></a>00084     <span class="keywordflow">if</span> (values_.empty()) <span class="keywordflow">return</span> 0.0;
<a name="l00085"></a>00085     <span class="keywordflow">return</span> values_[0];
<a name="l00086"></a>00086   }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="keywordtype">int</span> size()<span class="keyword"> const </span>{
<a name="l00089"></a>00089     <span class="keywordflow">return</span> values_.size();
<a name="l00090"></a>00090   }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092  <span class="keyword">private</span>:
<a name="l00093"></a>00093   <span class="keyword">static</span> <span class="keywordtype">int</span> float_compare(<span class="keyword">const</span> <span class="keywordtype">void</span>* a, <span class="keyword">const</span> <span class="keywordtype">void</span>* b) {
<a name="l00094"></a>00094     <span class="keyword">const</span> <span class="keywordtype">float</span>* f_a = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(a);
<a name="l00095"></a>00095     <span class="keyword">const</span> <span class="keywordtype">float</span>* f_b = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(b);
<a name="l00096"></a>00096     <span class="keywordflow">return</span> (*f_a &gt; *f_b) ? 1 : ((*f_a &lt; *f_b) ? -1 : 0);
<a name="l00097"></a>00097   }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   <span class="keywordtype">bool</span> finalized_;
<a name="l00100"></a>00100   <a class="code" href="class_generic_vector.html">GenericVector&lt;float&gt;</a> values_;
<a name="l00101"></a>00101 };
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="comment">// statistics for a small collection of float pairs (x, y).</span>
<a name="l00104"></a>00104 <span class="comment">// EstimateYFor(x, r) returns the estimated y at x, based on</span>
<a name="l00105"></a>00105 <span class="comment">// existing samples between x*(1-r) ~ x*(1+r).</span>
<a name="l00106"></a>00106 <span class="keyword">class </span>LocalCorrelation {
<a name="l00107"></a>00107  <span class="keyword">public</span>:
<a name="l00108"></a>00108   <span class="keyword">struct </span>float_pair {
<a name="l00109"></a>00109     <span class="keywordtype">float</span> x, y;
<a name="l00110"></a>00110     <span class="keywordtype">int</span> vote;
<a name="l00111"></a>00111   };
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   LocalCorrelation(): finalized_(false) { }
<a name="l00114"></a>00114   ~LocalCorrelation() { }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <span class="keywordtype">void</span> Finish() {
<a name="l00117"></a>00117     values_.sort(float_pair_compare);
<a name="l00118"></a>00118     finalized_ = <span class="keyword">true</span>;
<a name="l00119"></a>00119   }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordtype">void</span> Clear() {
<a name="l00122"></a>00122     finalized_ = <span class="keyword">false</span>;
<a name="l00123"></a>00123   }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="keywordtype">void</span> Add(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">int</span> v) {
<a name="l00126"></a>00126     <span class="keyword">struct </span>float_pair value;
<a name="l00127"></a>00127     value.x = x;
<a name="l00128"></a>00128     value.y = y;
<a name="l00129"></a>00129     value.vote = v;
<a name="l00130"></a>00130     values_.push_back(value);
<a name="l00131"></a>00131     finalized_ = <span class="keyword">false</span>;
<a name="l00132"></a>00132   }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   <span class="keywordtype">float</span> EstimateYFor(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> r) {
<a name="l00135"></a>00135     <a class="code" href="errcode_8h.html#a93a603f4063a6b9403d81caa245a583b">ASSERT_HOST</a>(finalized_);
<a name="l00136"></a>00136     <span class="keywordtype">int</span> start = 0, end = values_.size();
<a name="l00137"></a>00137     <span class="comment">// Because the number of samples (used_) is assumed to be small,</span>
<a name="l00138"></a>00138     <span class="comment">// just use linear search to find values within the range.</span>
<a name="l00139"></a>00139     <span class="keywordflow">while</span> (start &lt; values_.size() &amp;&amp; values_[start].x &lt; x * (1.0 - r)) start++;
<a name="l00140"></a>00140     <span class="keywordflow">while</span> (end - 1 &gt;= 0 &amp;&amp; values_[end - 1].x &gt; x * (1.0 + r)) end--;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     <span class="comment">// Fall back to the global average if there are no data within r</span>
<a name="l00143"></a>00143     <span class="comment">// of x.</span>
<a name="l00144"></a>00144     <span class="keywordflow">if</span> (start &gt;= end) {
<a name="l00145"></a>00145       start = 0;
<a name="l00146"></a>00146       end = values_.size();
<a name="l00147"></a>00147     }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149     <span class="comment">// Compute weighted average of the values.</span>
<a name="l00150"></a>00150     <span class="keywordtype">float</span> rc = 0;
<a name="l00151"></a>00151     <span class="keywordtype">int</span> vote = 0;
<a name="l00152"></a>00152     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = start; i &lt; end; i++) {
<a name="l00153"></a>00153       rc += values_[i].vote * x * values_[i].y / values_[i].x;
<a name="l00154"></a>00154       vote += values_[i].vote;
<a name="l00155"></a>00155     }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <span class="keywordflow">return</span> rc / vote;
<a name="l00158"></a>00158   }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160  <span class="keyword">private</span>:
<a name="l00161"></a>00161   <span class="keyword">static</span> <span class="keywordtype">int</span> float_pair_compare(<span class="keyword">const</span> <span class="keywordtype">void</span>* a, <span class="keyword">const</span> <span class="keywordtype">void</span>* b) {
<a name="l00162"></a>00162     <span class="keyword">const</span> float_pair* f_a = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>float_pair*<span class="keyword">&gt;</span>(a);
<a name="l00163"></a>00163     <span class="keyword">const</span> float_pair* f_b = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>float_pair*<span class="keyword">&gt;</span>(b);
<a name="l00164"></a>00164     <span class="keywordflow">return</span> (f_a-&gt;x &gt; f_b-&gt;x) ? 1 : ((f_a-&gt;x &lt; f_b-&gt;x) ? -1 : 0);
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="keywordtype">bool</span> finalized_;
<a name="l00168"></a>00168   <a class="code" href="class_generic_vector.html">GenericVector&lt;struct float_pair&gt;</a> values_;
<a name="l00169"></a>00169 };
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">// Class to represent a character on a fixed pitch row.  A FPChar may</span>
<a name="l00172"></a>00172 <span class="comment">// consist of multiple blobs (BLOBNBOX&#39;s).</span>
<a name="l00173"></a>00173 <span class="keyword">class </span>FPChar {
<a name="l00174"></a>00174  <span class="keyword">public</span>:
<a name="l00175"></a>00175   <span class="keyword">enum</span> Alignment {
<a name="l00176"></a>00176     ALIGN_UNKNOWN, ALIGN_GOOD, ALIGN_BAD
<a name="l00177"></a>00177   };
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   FPChar(): box_(), real_body_(),
<a name="l00180"></a>00180             from_(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>), to_(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>), num_blobs_(0), max_gap_(0),
<a name="l00181"></a>00181             final_(false), alignment_(ALIGN_UNKNOWN),
<a name="l00182"></a>00182             merge_to_prev_(false), delete_flag_(false) {
<a name="l00183"></a>00183   }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="comment">// Initialize from blob.</span>
<a name="l00186"></a>00186   <span class="keywordtype">void</span> Init(<a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a> *blob) {
<a name="l00187"></a>00187     box_ = blob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a7b97b8bc16b1473a28f9c44011522f4e">bounding_box</a>();
<a name="l00188"></a>00188     real_body_ = box_;
<a name="l00189"></a>00189     from_ = to_ = blob;
<a name="l00190"></a>00190     num_blobs_ = 1;
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">// Merge this character with &quot;next&quot;. The &quot;next&quot; character should</span>
<a name="l00194"></a>00194   <span class="comment">// consist of succeeding blobs on the same row.</span>
<a name="l00195"></a>00195   <span class="keywordtype">void</span> Merge(<span class="keyword">const</span> FPChar &amp;next) {
<a name="l00196"></a>00196     <span class="keywordtype">int</span> gap = real_body_.x_gap(next.real_body_);
<a name="l00197"></a>00197     <span class="keywordflow">if</span> (gap &gt; max_gap_) max_gap_ = gap;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     box_ += next.box_;
<a name="l00200"></a>00200     real_body_ += next.real_body_;
<a name="l00201"></a>00201     to_ = next.to_;
<a name="l00202"></a>00202     num_blobs_ += next.num_blobs_;
<a name="l00203"></a>00203   }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <span class="comment">// Accessors.</span>
<a name="l00206"></a>00206   <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a> &amp;box()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> box_; }
<a name="l00207"></a>00207   <span class="keywordtype">void</span> set_box(<span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a> &amp;box) {
<a name="l00208"></a>00208     box_ = box;
<a name="l00209"></a>00209   }
<a name="l00210"></a>00210   <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a> &amp;real_body()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> real_body_; }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="keywordtype">bool</span> is_final()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> final_; }
<a name="l00213"></a>00213   <span class="keywordtype">void</span> set_final(<span class="keywordtype">bool</span> flag) {
<a name="l00214"></a>00214     final_ = flag;
<a name="l00215"></a>00215   }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217   <span class="keyword">const</span> Alignment&amp; alignment()<span class="keyword"> const </span>{
<a name="l00218"></a>00218     <span class="keywordflow">return</span> alignment_;
<a name="l00219"></a>00219   }
<a name="l00220"></a>00220   <span class="keywordtype">void</span> set_alignment(Alignment alignment) {
<a name="l00221"></a>00221     alignment_ = alignment;
<a name="l00222"></a>00222   }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="keywordtype">bool</span> merge_to_prev()<span class="keyword"> const </span>{
<a name="l00225"></a>00225     <span class="keywordflow">return</span> merge_to_prev_;
<a name="l00226"></a>00226   }
<a name="l00227"></a>00227   <span class="keywordtype">void</span> set_merge_to_prev(<span class="keywordtype">bool</span> flag) {
<a name="l00228"></a>00228     merge_to_prev_ = flag;
<a name="l00229"></a>00229   }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="keywordtype">bool</span> delete_flag()<span class="keyword"> const </span>{
<a name="l00232"></a>00232     <span class="keywordflow">return</span> delete_flag_;
<a name="l00233"></a>00233   }
<a name="l00234"></a>00234   <span class="keywordtype">void</span> set_delete_flag(<span class="keywordtype">bool</span> flag) {
<a name="l00235"></a>00235     delete_flag_ = flag;
<a name="l00236"></a>00236   }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238   <span class="keywordtype">int</span> max_gap()<span class="keyword"> const </span>{
<a name="l00239"></a>00239     <span class="keywordflow">return</span> max_gap_;
<a name="l00240"></a>00240   }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="keywordtype">int</span> num_blobs()<span class="keyword"> const </span>{
<a name="l00243"></a>00243     <span class="keywordflow">return</span> num_blobs_;
<a name="l00244"></a>00244   }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246  <span class="keyword">private</span>:
<a name="l00247"></a>00247   <a class="code" href="class_t_b_o_x.html">TBOX</a> box_;  <span class="comment">// Rectangle region considered to be occupied by this</span>
<a name="l00248"></a>00248   <span class="comment">// character.  It could be bigger than the bounding box.</span>
<a name="l00249"></a>00249   <a class="code" href="class_t_b_o_x.html">TBOX</a> real_body_;  <span class="comment">// Real bounding box of this character.</span>
<a name="l00250"></a>00250   <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a> *from_;  <span class="comment">// The first blob of this character.</span>
<a name="l00251"></a>00251   <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a> *to_;  <span class="comment">// The last blob of this character.</span>
<a name="l00252"></a>00252   <span class="keywordtype">int</span> num_blobs_;  <span class="comment">// Number of blobs that belong to this character.</span>
<a name="l00253"></a>00253   <span class="keywordtype">int</span> max_gap_;  <span class="comment">// Maximum x gap between the blobs.</span>
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="keywordtype">bool</span> final_;  <span class="comment">// True if alignment/fragmentation decision for this</span>
<a name="l00256"></a>00256   <span class="comment">// character is finalized.</span>
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   Alignment alignment_;  <span class="comment">// Alignment status.</span>
<a name="l00259"></a>00259   <span class="keywordtype">bool</span> merge_to_prev_;  <span class="comment">// True if this is a fragmented blob that</span>
<a name="l00260"></a>00260   <span class="comment">// needs to be merged to the previous</span>
<a name="l00261"></a>00261   <span class="comment">// character.</span>
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   <span class="keywordtype">int</span> delete_flag_;  <span class="comment">// True if this character is merged to another</span>
<a name="l00264"></a>00264   <span class="comment">// one and needs to be deleted.</span>
<a name="l00265"></a>00265 };
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment">// Class to represent a fixed pitch row, as a linear collection of</span>
<a name="l00268"></a>00268 <span class="comment">// FPChar&#39;s.</span>
<a name="l00269"></a>00269 <span class="keyword">class </span>FPRow {
<a name="l00270"></a>00270  <span class="keyword">public</span>:
<a name="l00271"></a>00271   FPRow() : pitch_(0.0<a class="code" href="imgscale_8cpp.html#a469169df397b589e709dc744f1346831">f</a>), estimated_pitch_(0.0<a class="code" href="imgscale_8cpp.html#a469169df397b589e709dc744f1346831">f</a>),
<a name="l00272"></a>00272             all_pitches_(), all_gaps_(), good_pitches_(), good_gaps_(),
<a name="l00273"></a>00273             heights_(), characters_(), real_row_(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00274"></a>00274   }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   ~FPRow() { }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="comment">// Initialize from TD_ROW.</span>
<a name="l00279"></a>00279   <span class="keywordtype">void</span> Init(<a class="code" href="class_t_o___r_o_w.html">TO_ROW</a> *row);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   <span class="comment">// Estimate character pitch of this row, based on current alignment</span>
<a name="l00282"></a>00282   <span class="comment">// status of underlying FPChar&#39;s.  The argument pass1 can be set to</span>
<a name="l00283"></a>00283   <span class="comment">// true if the function is called after Pass1Analyze(), to eliminate</span>
<a name="l00284"></a>00284   <span class="comment">// some redundant computation.</span>
<a name="l00285"></a>00285   <span class="keywordtype">void</span> EstimatePitch(<span class="keywordtype">bool</span> pass1);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="comment">// Check each character if it has good character pitches between its</span>
<a name="l00288"></a>00288   <span class="comment">// predecessor and its successor and set its alignment status.  If</span>
<a name="l00289"></a>00289   <span class="comment">// we already calculated the estimated pitch for this row, the value</span>
<a name="l00290"></a>00290   <span class="comment">// is used.  If we didn&#39;t, a character is considered to be good, if</span>
<a name="l00291"></a>00291   <span class="comment">// the pitches between its predecessor and its successor are almost</span>
<a name="l00292"></a>00292   <span class="comment">// equal.</span>
<a name="l00293"></a>00293   <span class="keywordtype">void</span> Pass1Analyze();
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   <span class="comment">// Find characters that fit nicely into one imaginary body next to a</span>
<a name="l00296"></a>00296   <span class="comment">// character which is already finalized. Then mark them as character</span>
<a name="l00297"></a>00297   <span class="comment">// fragments.</span>
<a name="l00298"></a>00298   <span class="keywordtype">bool</span> Pass2Analyze();
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="comment">// Merge FPChars marked as character fragments into one.</span>
<a name="l00301"></a>00301   <span class="keywordtype">void</span> MergeFragments();
<a name="l00302"></a>00302 
<a name="l00303"></a>00303   <span class="comment">// Finalize characters that are already large enough and cannot be</span>
<a name="l00304"></a>00304   <span class="comment">// merged with others any more.</span>
<a name="l00305"></a>00305   <span class="keywordtype">void</span> FinalizeLargeChars();
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   <span class="comment">// Ouput pitch estimation results to attributes of TD_ROW.</span>
<a name="l00308"></a>00308   <span class="keywordtype">void</span> OutputEstimations();
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   <span class="keywordtype">void</span> DebugOutputResult(<span class="keywordtype">int</span> row_index);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312   <span class="keywordtype">int</span> good_pitches() {
<a name="l00313"></a>00313     <span class="keywordflow">return</span> good_pitches_.size();
<a name="l00314"></a>00314   }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordtype">int</span> good_gaps() {
<a name="l00317"></a>00317     <span class="keywordflow">return</span> good_gaps_.size();
<a name="l00318"></a>00318   }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="keywordtype">float</span> pitch() {
<a name="l00321"></a>00321     <span class="keywordflow">return</span> pitch_;
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="keywordtype">float</span> estimated_pitch() {
<a name="l00325"></a>00325     <span class="keywordflow">return</span> estimated_pitch_;
<a name="l00326"></a>00326   }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="keywordtype">void</span> set_estimated_pitch(<span class="keywordtype">float</span> v) {
<a name="l00329"></a>00329     estimated_pitch_ = v;
<a name="l00330"></a>00330   }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="keywordtype">float</span> height() {
<a name="l00333"></a>00333     <span class="keywordflow">return</span> height_;
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   <span class="keywordtype">float</span> height_pitch_ratio() {
<a name="l00337"></a>00337     <span class="keywordflow">if</span> (good_pitches_.size() &lt; 2) <span class="keywordflow">return</span> -1.0;
<a name="l00338"></a>00338     <span class="keywordflow">return</span> height_ / good_pitches_.median();
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   <span class="keywordtype">float</span> gap() {
<a name="l00342"></a>00342     <span class="keywordflow">return</span> gap_;
<a name="l00343"></a>00343   }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="keywordtype">int</span> num_chars() {
<a name="l00346"></a>00346     <span class="keywordflow">return</span> characters_.size();
<a name="l00347"></a>00347   }
<a name="l00348"></a>00348   FPChar *<a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(<span class="keywordtype">int</span> i) {
<a name="l00349"></a>00349     <span class="keywordflow">return</span> &amp;characters_[i];
<a name="l00350"></a>00350   }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a> &amp;box(<span class="keywordtype">int</span> i) {
<a name="l00353"></a>00353     <span class="keywordflow">return</span> characters_[i].box();
<a name="l00354"></a>00354   }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a> &amp;real_body(<span class="keywordtype">int</span> i) {
<a name="l00357"></a>00357     <span class="keywordflow">return</span> characters_[i].real_body();
<a name="l00358"></a>00358   }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="keywordtype">bool</span> is_box_modified(<span class="keywordtype">int</span> i) {
<a name="l00361"></a>00361     <span class="keywordflow">return</span> !(characters_[i].box() == characters_[i].real_body());
<a name="l00362"></a>00362   }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="keywordtype">float</span> center_x(<span class="keywordtype">int</span> i) {
<a name="l00365"></a>00365     <span class="keywordflow">return</span> (characters_[i].box().left() + characters_[i].box().right()) / 2.0;
<a name="l00366"></a>00366   }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="keywordtype">bool</span> is_final(<span class="keywordtype">int</span> i) {
<a name="l00369"></a>00369     <span class="keywordflow">return</span> characters_[i].is_final();
<a name="l00370"></a>00370   }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="keywordtype">void</span> finalize(<span class="keywordtype">int</span> i) {
<a name="l00373"></a>00373     characters_[i].set_final(<span class="keyword">true</span>);
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376   <span class="keywordtype">bool</span> is_good(<span class="keywordtype">int</span> i) {
<a name="l00377"></a>00377     <span class="keywordflow">return</span> characters_[i].alignment() == FPChar::ALIGN_GOOD;
<a name="l00378"></a>00378   }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="keywordtype">bool</span> is_bad(<span class="keywordtype">int</span> i) {
<a name="l00381"></a>00381     <span class="keywordflow">return</span> characters_[i].alignment() == FPChar::ALIGN_BAD;
<a name="l00382"></a>00382   }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   <span class="keywordtype">bool</span> is_unknown(<span class="keywordtype">int</span> i) {
<a name="l00385"></a>00385     <span class="keywordflow">return</span> characters_[i].alignment() == FPChar::ALIGN_UNKNOWN;
<a name="l00386"></a>00386   }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="keywordtype">void</span> mark_good(<span class="keywordtype">int</span> i) {
<a name="l00389"></a>00389     characters_[i].set_alignment(FPChar::ALIGN_GOOD);
<a name="l00390"></a>00390   }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="keywordtype">void</span> mark_bad(<span class="keywordtype">int</span> i) {
<a name="l00393"></a>00393     characters_[i].set_alignment(FPChar::ALIGN_BAD);
<a name="l00394"></a>00394   }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   <span class="keywordtype">void</span> clear_alignment(<span class="keywordtype">int</span> i) {
<a name="l00397"></a>00397     characters_[i].set_alignment(FPChar::ALIGN_UNKNOWN);
<a name="l00398"></a>00398   }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400  <span class="keyword">private</span>:
<a name="l00401"></a>00401   <span class="keyword">static</span> <span class="keywordtype">float</span> x_overlap_fraction(<span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box1, <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box2) {
<a name="l00402"></a>00402     <span class="keywordflow">if</span> (<a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>(box1.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>(), box2.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>()) == 0) <span class="keywordflow">return</span> 0.0;
<a name="l00403"></a>00403     <span class="keywordflow">return</span> -box1.<a class="code" href="class_t_b_o_x.html#a6c296f134aaae6ee544c4d000d76f80e">x_gap</a>(box2) / (float)<a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>(box1.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>(), box2.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>());
<a name="l00404"></a>00404   }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="keyword">static</span> <span class="keywordtype">bool</span> mostly_overlap(<span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box1, <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box2) {
<a name="l00407"></a>00407     <span class="keywordflow">return</span> x_overlap_fraction(box1, box2) &gt; 0.9;
<a name="l00408"></a>00408   }
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <span class="keyword">static</span> <span class="keywordtype">bool</span> significant_overlap(<span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box1, <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box2) {
<a name="l00411"></a>00411     <span class="keywordflow">if</span> (<a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>(box1.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>(), box2.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>()) == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00412"></a>00412     <span class="keywordtype">int</span> overlap = -box1.<a class="code" href="class_t_b_o_x.html#a6c296f134aaae6ee544c4d000d76f80e">x_gap</a>(box2);
<a name="l00413"></a>00413     <span class="keywordflow">return</span> overlap &gt; 1 || x_overlap_fraction(box1, box2) &gt; 0.1;
<a name="l00414"></a>00414   }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="keyword">static</span> <span class="keywordtype">float</span> box_pitch(<span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; ref, <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box) {
<a name="l00417"></a>00417     <span class="keywordflow">return</span> abs(ref.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>() + ref.<a class="code" href="class_t_b_o_x.html#a8703081c1a1c26db3a4dddaca1028e34">right</a>() - box.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>() - box.<a class="code" href="class_t_b_o_x.html#a8703081c1a1c26db3a4dddaca1028e34">right</a>()) / 2.0;
<a name="l00418"></a>00418   }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420   <span class="comment">// Check if two neighboring characters satisfy the fixed pitch model.</span>
<a name="l00421"></a>00421   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_good_pitch(<span class="keywordtype">float</span> pitch, <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box1, <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box2) {
<a name="l00422"></a>00422     <span class="comment">// Character box shouldn&#39;t exceed pitch.</span>
<a name="l00423"></a>00423     <span class="keywordflow">if</span> (box1.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>() &gt;= pitch * (1.0 + kFPTolerance) ||
<a name="l00424"></a>00424         box2.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>() &gt;= pitch * (1.0 + kFPTolerance) ||
<a name="l00425"></a>00425         box1.<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>() &gt;= pitch * (1.0 + kFPTolerance) ||
<a name="l00426"></a>00426         box2.<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>() &gt;= pitch * (1.0 + kFPTolerance)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="keyword">const</span> <span class="keywordtype">float</span> real_pitch = box_pitch(box1, box2);
<a name="l00429"></a>00429     <span class="keywordflow">if</span> (abs(real_pitch - pitch) &lt; pitch * kFPTolerance) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431     <span class="keywordflow">if</span> (<a class="code" href="cjkpitch_8cpp.html#ae487cd6731bb3f5515eced4c24adf033">textord_space_size_is_variable</a>) {
<a name="l00432"></a>00432       <span class="comment">// Hangul characters usually have fixed pitch, but words are</span>
<a name="l00433"></a>00433       <span class="comment">// delimited by space which can be narrower than characters.</span>
<a name="l00434"></a>00434       <span class="keywordflow">if</span> (real_pitch &gt; pitch &amp;&amp; real_pitch &lt; pitch * 2.0 &amp;&amp;
<a name="l00435"></a>00435           real_pitch - box1.<a class="code" href="class_t_b_o_x.html#a6c296f134aaae6ee544c4d000d76f80e">x_gap</a>(box2) &lt; pitch) {
<a name="l00436"></a>00436         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00437"></a>00437       }
<a name="l00438"></a>00438     }
<a name="l00439"></a>00439     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00440"></a>00440   }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_interesting_blob(<span class="keyword">const</span> <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a> *blob) {
<a name="l00443"></a>00443     <span class="keywordflow">return</span> !blob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#af37f373c72851534101f4caf296a3cf7">joined_to_prev</a>() &amp;&amp; blob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#afafe7113396a8cc27b882d622db46f05">flow</a>() != <a class="code" href="blobbox_8h.html#aa72f1499398e9694bf46752e1cc895e1a64e3e70c4fac4d4e3facdb4638307d7f">BTFT_LEADER</a>;
<a name="l00444"></a>00444   }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="comment">// Cleanup chars that are already merged to others.</span>
<a name="l00447"></a>00447   <span class="keywordtype">void</span> DeleteChars() {
<a name="l00448"></a>00448     <span class="keywordtype">int</span> index = 0;
<a name="l00449"></a>00449     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; characters_.size(); ++i) {
<a name="l00450"></a>00450       <span class="keywordflow">if</span> (!characters_[i].delete_flag()) {
<a name="l00451"></a>00451         <span class="keywordflow">if</span> (index != i) characters_[index] = characters_[i];
<a name="l00452"></a>00452         index++;
<a name="l00453"></a>00453       }
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455     characters_.truncate(index);
<a name="l00456"></a>00456   }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   <span class="keywordtype">float</span> pitch_;  <span class="comment">// Character pitch.</span>
<a name="l00459"></a>00459   <span class="keywordtype">float</span> estimated_pitch_;  <span class="comment">// equal to pitch_ if pitch_ is considered</span>
<a name="l00460"></a>00460   <span class="comment">// to be good enough.</span>
<a name="l00461"></a>00461   <span class="keywordtype">float</span> height_;  <span class="comment">// Character height.</span>
<a name="l00462"></a>00462   <span class="keywordtype">float</span> gap_;  <span class="comment">// Minimum gap between characters.</span>
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="comment">// Pitches between any two successive characters.</span>
<a name="l00465"></a>00465   SimpleStats all_pitches_;
<a name="l00466"></a>00466   <span class="comment">// Gaps between any two successive characters.</span>
<a name="l00467"></a>00467   SimpleStats all_gaps_;
<a name="l00468"></a>00468   <span class="comment">// Pitches between any two successive characters that are consistent</span>
<a name="l00469"></a>00469   <span class="comment">// with the fixed pitch model.</span>
<a name="l00470"></a>00470   SimpleStats good_pitches_;
<a name="l00471"></a>00471   <span class="comment">// Gaps between any two successive characters that are consistent</span>
<a name="l00472"></a>00472   <span class="comment">// with the fixed pitch model.</span>
<a name="l00473"></a>00473   SimpleStats good_gaps_;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475   SimpleStats heights_;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <a class="code" href="class_generic_vector.html">GenericVector&lt;FPChar&gt;</a> characters_;
<a name="l00478"></a>00478   <a class="code" href="class_t_o___r_o_w.html">TO_ROW</a> *real_row_;  <span class="comment">// Underlying TD_ROW for this row.</span>
<a name="l00479"></a>00479 };
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="keywordtype">void</span> FPRow::Init(<a class="code" href="class_t_o___r_o_w.html">TO_ROW</a> *row) {
<a name="l00482"></a>00482   <a class="code" href="errcode_8h.html#a93a603f4063a6b9403d81caa245a583b">ASSERT_HOST</a>(row != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00483"></a>00483   <a class="code" href="errcode_8h.html#a93a603f4063a6b9403d81caa245a583b">ASSERT_HOST</a>(row-&gt;<a class="code" href="class_t_o___r_o_w.html#a819d94a95b9aab802acbcba097c67b2b">xheight</a> &gt; 0);
<a name="l00484"></a>00484   real_row_ = row;
<a name="l00485"></a>00485   real_row_-&gt;<a class="code" href="class_t_o___r_o_w.html#a86c03914f286e37cbbc30e341cf6c253">pitch_decision</a> = <a class="code" href="blobbox_8h.html#a4c698e96e1ebeb67e13f584c524fd154aa44925f7147c8bb8948712ba9fbe55d3">PITCH_CORR_PROP</a>;  <span class="comment">// Default decision.</span>
<a name="l00486"></a>00486 
<a name="l00487"></a>00487   BLOBNBOX_IT blob_it = row-&gt;<a class="code" href="class_t_o___r_o_w.html#a39cee94572e70d35179c27cdf21a3022">blob_list</a>();
<a name="l00488"></a>00488   <span class="comment">// Initialize characters_ and compute the initial estimation of</span>
<a name="l00489"></a>00489   <span class="comment">// character height.</span>
<a name="l00490"></a>00490   <span class="keywordflow">for</span> (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
<a name="l00491"></a>00491     <span class="keywordflow">if</span> (is_interesting_blob(blob_it.data())) {
<a name="l00492"></a>00492       FPChar fp_char;
<a name="l00493"></a>00493       fp_char.Init(blob_it.data());
<a name="l00494"></a>00494       <span class="comment">// Merge unconditionally if two blobs overlap.</span>
<a name="l00495"></a>00495       <span class="keywordflow">if</span> (!characters_.empty() &amp;&amp;
<a name="l00496"></a>00496           significant_overlap(fp_char.box(), characters_.back().box())) {
<a name="l00497"></a>00497         characters_.back().Merge(fp_char);
<a name="l00498"></a>00498       } <span class="keywordflow">else</span> {
<a name="l00499"></a>00499         characters_.push_back(fp_char);
<a name="l00500"></a>00500       }
<a name="l00501"></a>00501       <a class="code" href="class_t_b_o_x.html">TBOX</a> bound = blob_it.data()-&gt;bounding_box();
<a name="l00502"></a>00502       <span class="keywordflow">if</span> (bound.<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>() * 3.0 &gt; bound.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>()) {
<a name="l00503"></a>00503         heights_.Add(bound.<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>());
<a name="l00504"></a>00504       }
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506   }
<a name="l00507"></a>00507   heights_.Finish();
<a name="l00508"></a>00508   height_ = heights_.ile(0.875);
<a name="l00509"></a>00509 }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="keywordtype">void</span> FPRow::OutputEstimations() {
<a name="l00512"></a>00512   <span class="keywordflow">if</span> (good_pitches_.size() == 0) {
<a name="l00513"></a>00513     pitch_ = 0.0f;
<a name="l00514"></a>00514     real_row_-&gt;pitch_decision = <a class="code" href="blobbox_8h.html#a4c698e96e1ebeb67e13f584c524fd154aa44925f7147c8bb8948712ba9fbe55d3">PITCH_CORR_PROP</a>;
<a name="l00515"></a>00515     <span class="keywordflow">return</span>;
<a name="l00516"></a>00516   }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   pitch_ = good_pitches_.median();
<a name="l00519"></a>00519   real_row_-&gt;fixed_pitch = pitch_;
<a name="l00520"></a>00520   <span class="comment">// good_gaps_.ile(0.125) can be large if most characters on the row</span>
<a name="l00521"></a>00521   <span class="comment">// are skinny. Use pitch_ - height_ instead if it&#39;s smaller, but</span>
<a name="l00522"></a>00522   <span class="comment">// positive.</span>
<a name="l00523"></a>00523   real_row_-&gt;kern_size = real_row_-&gt;pr_nonsp =
<a name="l00524"></a>00524       <a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>(good_gaps_.ile(0.125), <a class="code" href="ndminx_8h.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(pitch_ - height_, 0));
<a name="l00525"></a>00525   real_row_-&gt;body_size = pitch_ - real_row_-&gt;kern_size;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527   <span class="keywordflow">if</span> (good_pitches_.size() &lt; all_pitches_.size() * kFixedPitchThreshold) {
<a name="l00528"></a>00528     <span class="comment">// If more than half of the characters of a line don&#39;t fit to the</span>
<a name="l00529"></a>00529     <span class="comment">// fixed pitch model, consider the line to be propotional. 50%</span>
<a name="l00530"></a>00530     <span class="comment">// seems to be a good threshold in practice as well.</span>
<a name="l00531"></a>00531     <span class="comment">// Anyway we store estimated values (fixed_pitch, kern_size, etc.) in</span>
<a name="l00532"></a>00532     <span class="comment">// real_row_ as a partial estimation result and try to use them in the</span>
<a name="l00533"></a>00533     <span class="comment">// normalization process.</span>
<a name="l00534"></a>00534     real_row_-&gt;pitch_decision = <a class="code" href="blobbox_8h.html#a4c698e96e1ebeb67e13f584c524fd154aa44925f7147c8bb8948712ba9fbe55d3">PITCH_CORR_PROP</a>;
<a name="l00535"></a>00535     <span class="keywordflow">return</span>;
<a name="l00536"></a>00536   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (good_pitches_.size() &gt; all_pitches_.size() * 0.75) {
<a name="l00537"></a>00537     real_row_-&gt;pitch_decision = <a class="code" href="blobbox_8h.html#a4c698e96e1ebeb67e13f584c524fd154a0cba173121a328d3cb40be58bb3fd372">PITCH_DEF_FIXED</a>;
<a name="l00538"></a>00538   } <span class="keywordflow">else</span> {
<a name="l00539"></a>00539     real_row_-&gt;pitch_decision = <a class="code" href="blobbox_8h.html#a4c698e96e1ebeb67e13f584c524fd154a66d4c50c3dfbe049f0600dbff10ec362">PITCH_CORR_FIXED</a>;
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   real_row_-&gt;space_size = real_row_-&gt;pr_space = pitch_;
<a name="l00543"></a>00543   <span class="comment">// Set min_space to 50% of character pitch so that we can break CJK</span>
<a name="l00544"></a>00544   <span class="comment">// text at a half-width space after punctuation.</span>
<a name="l00545"></a>00545   real_row_-&gt;min_space = (pitch_ + good_gaps_.minimum()) * 0.5;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <span class="comment">// Don&#39;t consider a quarter space as a real space, because it&#39;s used</span>
<a name="l00548"></a>00548   <span class="comment">// for line justification in traditional Japanese books.</span>
<a name="l00549"></a>00549   real_row_-&gt;max_nonspace = <a class="code" href="ndminx_8h.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(pitch_ * 0.25 + good_gaps_.minimum(),
<a name="l00550"></a>00550                                 (double)good_gaps_.ile(0.875));
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   <span class="keywordtype">int</span> space_threshold =
<a name="l00553"></a>00553       <a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>((real_row_-&gt;max_nonspace + real_row_-&gt;min_space) / 2,
<a name="l00554"></a>00554           real_row_-&gt;xheight);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   <span class="comment">// Make max_nonspace larger than any intra-character gap so that</span>
<a name="l00557"></a>00557   <span class="comment">// make_prop_words() won&#39;t break a row at the middle of a character.</span>
<a name="l00558"></a>00558   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_chars(); ++i) {
<a name="l00559"></a>00559     <span class="keywordflow">if</span> (characters_[i].max_gap() &gt; real_row_-&gt;max_nonspace) {
<a name="l00560"></a>00560       real_row_-&gt;max_nonspace = characters_[i].max_gap();
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562   }
<a name="l00563"></a>00563   real_row_-&gt;space_threshold =
<a name="l00564"></a>00564       <a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>((real_row_-&gt;max_nonspace + real_row_-&gt;min_space) / 2,
<a name="l00565"></a>00565           real_row_-&gt;xheight);
<a name="l00566"></a>00566   real_row_-&gt;used_dm_model = <span class="keyword">false</span>;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568   <span class="comment">// Setup char_cells.</span>
<a name="l00569"></a>00569   ICOORDELT_IT cell_it = &amp;real_row_-&gt;char_cells;
<a name="l00570"></a>00570   <a class="code" href="class_i_c_o_o_r_d_e_l_t.html">ICOORDELT</a> *cell = <span class="keyword">new</span> <a class="code" href="class_i_c_o_o_r_d_e_l_t.html">ICOORDELT</a>(real_body(0).left(), 0);
<a name="l00571"></a>00571   cell_it.add_after_then_move(cell);
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="keywordtype">int</span> right = real_body(0).right();
<a name="l00574"></a>00574   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; num_chars(); ++i) {
<a name="l00575"></a>00575     <span class="comment">// Put a word break if gap between two characters is bigger than</span>
<a name="l00576"></a>00576     <span class="comment">// space_threshold.  Don&#39;t break if none of two characters</span>
<a name="l00577"></a>00577     <span class="comment">// couldn&#39;t be &quot;finalized&quot;, because maybe they need to be merged</span>
<a name="l00578"></a>00578     <span class="comment">// to one character.</span>
<a name="l00579"></a>00579     <span class="keywordflow">if</span> ((is_final(i - 1) || is_final(i)) &amp;&amp;
<a name="l00580"></a>00580         real_body(i - 1).x_gap(real_body(i)) &gt; space_threshold) {
<a name="l00581"></a>00581       cell = <span class="keyword">new</span> <a class="code" href="class_i_c_o_o_r_d_e_l_t.html">ICOORDELT</a>(right + 1, 0);
<a name="l00582"></a>00582       cell_it.add_after_then_move(cell);
<a name="l00583"></a>00583       <span class="keywordflow">while</span> (right + pitch_ &lt; box(i).left()) {
<a name="l00584"></a>00584         right += pitch_;
<a name="l00585"></a>00585         cell = <span class="keyword">new</span> <a class="code" href="class_i_c_o_o_r_d_e_l_t.html">ICOORDELT</a>(right + 1, 0);
<a name="l00586"></a>00586         cell_it.add_after_then_move(cell);
<a name="l00587"></a>00587       }
<a name="l00588"></a>00588       right = box(i).<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>();
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590     cell = <span class="keyword">new</span> <a class="code" href="class_i_c_o_o_r_d_e_l_t.html">ICOORDELT</a>((right + real_body(i).left()) / 2, 0);
<a name="l00591"></a>00591     cell_it.add_after_then_move(cell);
<a name="l00592"></a>00592     right = real_body(i).right();
<a name="l00593"></a>00593   }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   cell = <span class="keyword">new</span> <a class="code" href="class_i_c_o_o_r_d_e_l_t.html">ICOORDELT</a>(right + 1, 0);
<a name="l00596"></a>00596   cell_it.add_after_then_move(cell);
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   <span class="comment">// TODO(takenaka): add code to store alignment/fragmentation</span>
<a name="l00599"></a>00599   <span class="comment">// information to blobs so that it can be reused later, e.g. in</span>
<a name="l00600"></a>00600   <span class="comment">// recognition phase.</span>
<a name="l00601"></a>00601 }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="keywordtype">void</span> FPRow::EstimatePitch(<span class="keywordtype">bool</span> pass1) {
<a name="l00604"></a>00604   good_pitches_.Clear();
<a name="l00605"></a>00605   all_pitches_.Clear();
<a name="l00606"></a>00606   good_gaps_.Clear();
<a name="l00607"></a>00607   all_gaps_.Clear();
<a name="l00608"></a>00608   heights_.Clear();
<a name="l00609"></a>00609   <span class="keywordflow">if</span> (num_chars() == 0) <span class="keywordflow">return</span>;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <a class="code" href="host_8h.html#aba1f582fd0168f3ff9225d8c90fa9eb8">inT32</a> cx0, cx1;
<a name="l00612"></a>00612   <span class="keywordtype">bool</span> prev_was_good = is_good(0);
<a name="l00613"></a>00613   cx0 = center_x(0);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   heights_.Add(box(0).height());
<a name="l00616"></a>00616   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; num_chars(); i++) {
<a name="l00617"></a>00617     cx1 = center_x(i);
<a name="l00618"></a>00618     <a class="code" href="host_8h.html#aba1f582fd0168f3ff9225d8c90fa9eb8">inT32</a> pitch = cx1 - cx0;
<a name="l00619"></a>00619     <a class="code" href="host_8h.html#aba1f582fd0168f3ff9225d8c90fa9eb8">inT32</a> gap = <a class="code" href="ndminx_8h.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(0, real_body(i - 1).x_gap(real_body(i)));
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     heights_.Add(box(i).height());
<a name="l00622"></a>00622     <span class="comment">// Ignore if the pitch is too close.  But don&#39;t ignore wide pitch</span>
<a name="l00623"></a>00623     <span class="comment">// may be the result of large tracking.</span>
<a name="l00624"></a>00624     <span class="keywordflow">if</span> (pitch &gt; height_ * 0.5) {
<a name="l00625"></a>00625       all_pitches_.Add(pitch);
<a name="l00626"></a>00626       all_gaps_.Add(gap);
<a name="l00627"></a>00627       <span class="keywordflow">if</span> (is_good(i)) {
<a name="l00628"></a>00628         <span class="comment">// In pass1 (after Pass1Analyze()), all characters marked as</span>
<a name="l00629"></a>00629         <span class="comment">// &quot;good&quot; have a good consistent pitch with their previous</span>
<a name="l00630"></a>00630         <span class="comment">// characters.  However, it&#39;s not true in pass2 and a good</span>
<a name="l00631"></a>00631         <span class="comment">// character may have a good pitch only between its successor.</span>
<a name="l00632"></a>00632         <span class="comment">// So we collect only pitch values between two good</span>
<a name="l00633"></a>00633         <span class="comment">// characters. and within tolerance in pass2.</span>
<a name="l00634"></a>00634         <span class="keywordflow">if</span> (pass1 ||
<a name="l00635"></a>00635             (prev_was_good &amp;&amp;
<a name="l00636"></a>00636              abs(estimated_pitch_ - pitch) &lt; kFPTolerance * estimated_pitch_)) {
<a name="l00637"></a>00637           good_pitches_.Add(pitch);
<a name="l00638"></a>00638           <span class="keywordflow">if</span> (!is_box_modified(i - 1) &amp;&amp; !is_box_modified(i)) {
<a name="l00639"></a>00639             good_gaps_.Add(gap);
<a name="l00640"></a>00640           }
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642         prev_was_good = <span class="keyword">true</span>;
<a name="l00643"></a>00643       } <span class="keywordflow">else</span> {
<a name="l00644"></a>00644         prev_was_good = <span class="keyword">false</span>;
<a name="l00645"></a>00645       }
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647     cx0 = cx1;
<a name="l00648"></a>00648   }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   good_pitches_.Finish();
<a name="l00651"></a>00651   all_pitches_.Finish();
<a name="l00652"></a>00652   good_gaps_.Finish();
<a name="l00653"></a>00653   all_gaps_.Finish();
<a name="l00654"></a>00654   heights_.Finish();
<a name="l00655"></a>00655 
<a name="l00656"></a>00656   height_ = heights_.ile(0.875);
<a name="l00657"></a>00657   <span class="keywordflow">if</span> (all_pitches_.size() == 0) {
<a name="l00658"></a>00658     pitch_ = 0.0f;
<a name="l00659"></a>00659     gap_ = 0.0f;
<a name="l00660"></a>00660   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (good_pitches_.size() &lt; 2) {
<a name="l00661"></a>00661     <span class="comment">// We don&#39;t have enough data to estimate the pitch of this row yet.</span>
<a name="l00662"></a>00662     <span class="comment">// Use median of all pitches as the initial guess.</span>
<a name="l00663"></a>00663     pitch_ = all_pitches_.median();
<a name="l00664"></a>00664     <a class="code" href="errcode_8h.html#a93a603f4063a6b9403d81caa245a583b">ASSERT_HOST</a>(pitch_ &gt; 0.0<a class="code" href="imgscale_8cpp.html#a469169df397b589e709dc744f1346831">f</a>);
<a name="l00665"></a>00665     gap_ = all_gaps_.ile(0.125);
<a name="l00666"></a>00666   } <span class="keywordflow">else</span> {
<a name="l00667"></a>00667     pitch_ = good_pitches_.median();
<a name="l00668"></a>00668     <a class="code" href="errcode_8h.html#a93a603f4063a6b9403d81caa245a583b">ASSERT_HOST</a>(pitch_ &gt; 0.0<a class="code" href="imgscale_8cpp.html#a469169df397b589e709dc744f1346831">f</a>);
<a name="l00669"></a>00669     gap_ = good_gaps_.ile(0.125);
<a name="l00670"></a>00670   }
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="keywordtype">void</span> FPRow::DebugOutputResult(<span class="keywordtype">int</span> row_index) {
<a name="l00674"></a>00674   <span class="keywordflow">if</span> (num_chars() &gt; 0) {
<a name="l00675"></a>00675     <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;Row %d: pitch_decision=%d, fixed_pitch=%f, max_nonspace=%d, &quot;</span>
<a name="l00676"></a>00676             <span class="stringliteral">&quot;space_size=%f, space_threshold=%d, xheight=%f\n&quot;</span>,
<a name="l00677"></a>00677             row_index, (<span class="keywordtype">int</span>)(real_row_-&gt;pitch_decision),
<a name="l00678"></a>00678             real_row_-&gt;fixed_pitch, real_row_-&gt;max_nonspace,
<a name="l00679"></a>00679             real_row_-&gt;space_size, real_row_-&gt;space_threshold,
<a name="l00680"></a>00680             real_row_-&gt;xheight);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_chars(); i++) {
<a name="l00683"></a>00683       <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;Char %d: is_final=%d is_good=%d num_blobs=%d: &quot;</span>,
<a name="l00684"></a>00684               i, is_final(i), is_good(i), <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;num_blobs());
<a name="l00685"></a>00685       box(i).<a class="code" href="class_t_b_o_x.html#a2e753aa9943276301d68e9f9cad99620">print</a>();
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687   }
<a name="l00688"></a>00688 }
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 <span class="keywordtype">void</span> FPRow::Pass1Analyze() {
<a name="l00691"></a>00691   <span class="keywordflow">if</span> (num_chars() &lt; 2) <span class="keywordflow">return</span>;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   <span class="keywordflow">if</span> (estimated_pitch_ &gt; 0.0<a class="code" href="imgscale_8cpp.html#a469169df397b589e709dc744f1346831">f</a>) {
<a name="l00694"></a>00694     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt; num_chars(); i++) {
<a name="l00695"></a>00695       <span class="keywordflow">if</span> (is_good_pitch(estimated_pitch_, box(i - 2), box(i-1)) &amp;&amp;
<a name="l00696"></a>00696           is_good_pitch(estimated_pitch_, box(i - 1), box(i))) {
<a name="l00697"></a>00697         mark_good(i - 1);
<a name="l00698"></a>00698       }
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700   } <span class="keywordflow">else</span> {
<a name="l00701"></a>00701     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt; num_chars(); i++) {
<a name="l00702"></a>00702       <span class="keywordflow">if</span> (is_good_pitch(box_pitch(box(i-2), box(i-1)), box(i - 1), box(i))) {
<a name="l00703"></a>00703         mark_good(i - 1);
<a name="l00704"></a>00704       }
<a name="l00705"></a>00705     }
<a name="l00706"></a>00706   }
<a name="l00707"></a>00707   <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(0)-&gt;set_alignment(<a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(1)-&gt;alignment());
<a name="l00708"></a>00708   <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(num_chars() - 1)-&gt;set_alignment(
<a name="l00709"></a>00709       <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(num_chars() - 2)-&gt;alignment());
<a name="l00710"></a>00710 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="keywordtype">bool</span> FPRow::Pass2Analyze() {
<a name="l00713"></a>00713   <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;
<a name="l00714"></a>00714   <span class="keywordflow">if</span> (num_chars() &lt;= 1 || estimated_pitch_ == 0.0<a class="code" href="imgscale_8cpp.html#a469169df397b589e709dc744f1346831">f</a>) {
<a name="l00715"></a>00715     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00716"></a>00716   }
<a name="l00717"></a>00717   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_chars(); i++) {
<a name="l00718"></a>00718     <span class="keywordflow">if</span> (is_final(i)) <span class="keywordflow">continue</span>;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     FPChar::Alignment alignment = <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;alignment();
<a name="l00721"></a>00721     <span class="keywordtype">bool</span> intersecting = <span class="keyword">false</span>;
<a name="l00722"></a>00722     <span class="keywordtype">bool</span> not_intersecting = <span class="keyword">false</span>;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724     <span class="keywordflow">if</span> (i &lt; num_chars() - 1 &amp;&amp; is_final(i + 1)) {
<a name="l00725"></a>00725       <span class="comment">// Next character is already finalized. Estimate the imaginary</span>
<a name="l00726"></a>00726       <span class="comment">// body including this character based on the character. Skip</span>
<a name="l00727"></a>00727       <span class="comment">// whitespace if necessary.</span>
<a name="l00728"></a>00728       <span class="keywordtype">bool</span> skipped_whitespaces = <span class="keyword">false</span>;
<a name="l00729"></a>00729       <span class="keywordtype">float</span> c1 = center_x(i + 1)  - 1.5 * estimated_pitch_;
<a name="l00730"></a>00730       <span class="keywordflow">while</span> (c1 &gt; box(i).right()) {
<a name="l00731"></a>00731         skipped_whitespaces = <span class="keyword">true</span>;
<a name="l00732"></a>00732         c1 -= estimated_pitch_;
<a name="l00733"></a>00733       }
<a name="l00734"></a>00734       <a class="code" href="class_t_b_o_x.html">TBOX</a> ibody(c1, box(i).bottom(), c1 + estimated_pitch_, box(i).top());
<a name="l00735"></a>00735 
<a name="l00736"></a>00736       <span class="comment">// Collect all characters that mostly fit in the region.</span>
<a name="l00737"></a>00737       <span class="comment">// Also, their union height shouldn&#39;t be too big.</span>
<a name="l00738"></a>00738       <span class="keywordtype">int</span> j = i;
<a name="l00739"></a>00739       <a class="code" href="class_t_b_o_x.html">TBOX</a> merged;
<a name="l00740"></a>00740       <span class="keywordflow">while</span> (j &gt;= 0 &amp;&amp; !is_final(j) &amp;&amp; mostly_overlap(ibody, box(j)) &amp;&amp;
<a name="l00741"></a>00741              merged.<a class="code" href="class_t_b_o_x.html#ab8ae7b66782fa1802f78ff034da16089">bounding_union</a>(box(j)).<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>() &lt;
<a name="l00742"></a>00742              estimated_pitch_ * (1 + kFPTolerance)) {
<a name="l00743"></a>00743         merged += box(j);
<a name="l00744"></a>00744         j--;
<a name="l00745"></a>00745       }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747       <span class="keywordflow">if</span> (j &gt;= 0 &amp;&amp; significant_overlap(ibody, box(j))) {
<a name="l00748"></a>00748         <span class="comment">// character(j) lies on the character boundary and doesn&#39;t fit</span>
<a name="l00749"></a>00749         <span class="comment">// well into the imaginary body.</span>
<a name="l00750"></a>00750         <span class="keywordflow">if</span> (!is_final(j)) intersecting = <span class="keyword">true</span>;
<a name="l00751"></a>00751       } <span class="keywordflow">else</span> {
<a name="l00752"></a>00752         not_intersecting = <span class="keyword">true</span>;
<a name="l00753"></a>00753         <span class="keywordflow">if</span> (i - j &gt; 0) {
<a name="l00754"></a>00754           <span class="comment">// Merge character(j+1) ... character(i) because they fit</span>
<a name="l00755"></a>00755           <span class="comment">// into the body nicely.</span>
<a name="l00756"></a>00756           <span class="keywordflow">if</span> (i - j == 1) {
<a name="l00757"></a>00757             <span class="comment">// Only one char in the imaginary body.</span>
<a name="l00758"></a>00758             <span class="keywordflow">if</span> (!skipped_whitespaces) mark_good(i);
<a name="l00759"></a>00759             <span class="comment">// set ibody as bounding box of this character to get</span>
<a name="l00760"></a>00760             <span class="comment">// better pitch analysis result for halfwidth glyphs</span>
<a name="l00761"></a>00761             <span class="comment">// followed by a halfwidth space.</span>
<a name="l00762"></a>00762             <span class="keywordflow">if</span> (box(i).width() &lt;= estimated_pitch_ * 0.5) {
<a name="l00763"></a>00763               ibody += box(i);
<a name="l00764"></a>00764               <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;set_box(ibody);
<a name="l00765"></a>00765             }
<a name="l00766"></a>00766             <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;set_merge_to_prev(<span class="keyword">false</span>);
<a name="l00767"></a>00767             finalize(i);
<a name="l00768"></a>00768           } <span class="keywordflow">else</span> {
<a name="l00769"></a>00769             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = i; k &gt; j + 1; k--) {
<a name="l00770"></a>00770               <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(k)-&gt;set_merge_to_prev(<span class="keyword">true</span>);
<a name="l00771"></a>00771             }
<a name="l00772"></a>00772           }
<a name="l00773"></a>00773         }
<a name="l00774"></a>00774       }
<a name="l00775"></a>00775     }
<a name="l00776"></a>00776     <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; is_final(i - 1)) {
<a name="l00777"></a>00777       <span class="comment">// Now we repeat everything from the opposite side.  Previous</span>
<a name="l00778"></a>00778       <span class="comment">// character is already finalized. Estimate the imaginary body</span>
<a name="l00779"></a>00779       <span class="comment">// including this character based on the character.</span>
<a name="l00780"></a>00780       <span class="keywordtype">bool</span> skipped_whitespaces = <span class="keyword">false</span>;
<a name="l00781"></a>00781       <span class="keywordtype">float</span> c1 = center_x(i - 1) + 1.5 * estimated_pitch_;
<a name="l00782"></a>00782       <span class="keywordflow">while</span> (c1 &lt; box(i).left()) {
<a name="l00783"></a>00783         skipped_whitespaces = <span class="keyword">true</span>;
<a name="l00784"></a>00784         c1 += estimated_pitch_;
<a name="l00785"></a>00785       }
<a name="l00786"></a>00786       <a class="code" href="class_t_b_o_x.html">TBOX</a> ibody(c1 - estimated_pitch_, box(i).bottom(), c1, box(i).top());
<a name="l00787"></a>00787 
<a name="l00788"></a>00788       <span class="keywordtype">int</span> j = i;
<a name="l00789"></a>00789       <a class="code" href="class_t_b_o_x.html">TBOX</a> merged;
<a name="l00790"></a>00790       <span class="keywordflow">while</span> (j &lt; num_chars() &amp;&amp; !is_final(j) &amp;&amp; mostly_overlap(ibody, box(j)) &amp;&amp;
<a name="l00791"></a>00791              merged.<a class="code" href="class_t_b_o_x.html#ab8ae7b66782fa1802f78ff034da16089">bounding_union</a>(box(j)).<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>() &lt;
<a name="l00792"></a>00792              estimated_pitch_ * (1 + kFPTolerance)) {
<a name="l00793"></a>00793         merged += box(j);
<a name="l00794"></a>00794         j++;
<a name="l00795"></a>00795       }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797       <span class="keywordflow">if</span> (j &lt; num_chars() &amp;&amp; significant_overlap(ibody, box(j))) {
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (!is_final(j)) intersecting = <span class="keyword">true</span>;
<a name="l00799"></a>00799       } <span class="keywordflow">else</span> {
<a name="l00800"></a>00800         not_intersecting = <span class="keyword">true</span>;
<a name="l00801"></a>00801         <span class="keywordflow">if</span> (j - i &gt; 0) {
<a name="l00802"></a>00802           <span class="keywordflow">if</span> (j - i == 1) {
<a name="l00803"></a>00803             <span class="keywordflow">if</span> (!skipped_whitespaces) mark_good(i);
<a name="l00804"></a>00804             <span class="keywordflow">if</span> (box(i).width() &lt;= estimated_pitch_ * 0.5) {
<a name="l00805"></a>00805               ibody += box(i);
<a name="l00806"></a>00806               <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;set_box(ibody);
<a name="l00807"></a>00807             }
<a name="l00808"></a>00808             <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;set_merge_to_prev(<span class="keyword">false</span>);
<a name="l00809"></a>00809             finalize(i);
<a name="l00810"></a>00810           } <span class="keywordflow">else</span> {
<a name="l00811"></a>00811             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = i + 1; k &lt; j; k++) {
<a name="l00812"></a>00812               <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(k)-&gt;set_merge_to_prev(<span class="keyword">true</span>);
<a name="l00813"></a>00813             }
<a name="l00814"></a>00814           }
<a name="l00815"></a>00815         }
<a name="l00816"></a>00816       }
<a name="l00817"></a>00817     }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819     <span class="comment">// This character doesn&#39;t fit well into the estimated imaginary</span>
<a name="l00820"></a>00820     <span class="comment">// bodies. Mark it as bad.</span>
<a name="l00821"></a>00821     <span class="keywordflow">if</span> (intersecting &amp;&amp; !not_intersecting) mark_bad(i);
<a name="l00822"></a>00822     <span class="keywordflow">if</span> (<a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;alignment() != alignment ||
<a name="l00823"></a>00823         <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(i)-&gt;merge_to_prev()) {
<a name="l00824"></a>00824       changed = <span class="keyword">true</span>;
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="keywordflow">return</span> changed;
<a name="l00829"></a>00829 }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 <span class="keywordtype">void</span> FPRow::MergeFragments() {
<a name="l00832"></a>00832   <span class="keywordtype">int</span> last_char = 0;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; num_chars(); ++j) {
<a name="l00835"></a>00835     <span class="keywordflow">if</span> (<a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(j)-&gt;merge_to_prev()) {
<a name="l00836"></a>00836       <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(last_char)-&gt;Merge(*<a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(j));
<a name="l00837"></a>00837       <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(j)-&gt;set_delete_flag(<span class="keyword">true</span>);
<a name="l00838"></a>00838       clear_alignment(last_char);
<a name="l00839"></a>00839       <a class="code" href="mfoutline_8h.html#a2a4b69f9a2827dc98bc4cbc233118865afa40ef3af4fea0001b535318130960b2">character</a>(j-1)-&gt;set_merge_to_prev(<span class="keyword">false</span>);
<a name="l00840"></a>00840     } <span class="keywordflow">else</span> {
<a name="l00841"></a>00841       last_char = j;
<a name="l00842"></a>00842     }
<a name="l00843"></a>00843   }
<a name="l00844"></a>00844   DeleteChars();
<a name="l00845"></a>00845 }
<a name="l00846"></a>00846 
<a name="l00847"></a>00847 <span class="keywordtype">void</span> FPRow::FinalizeLargeChars() {
<a name="l00848"></a>00848   <span class="keywordtype">float</span> row_pitch = estimated_pitch();
<a name="l00849"></a>00849   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_chars(); i++) {
<a name="l00850"></a>00850     <span class="keywordflow">if</span> (is_final(i)) <span class="keywordflow">continue</span>;
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     <span class="comment">// Finalize if both neighbors are finalized. We have no other choice.</span>
<a name="l00853"></a>00853     <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; is_final(i - 1) &amp;&amp; i &lt; num_chars() - 1 &amp;&amp; is_final(i + 1)) {
<a name="l00854"></a>00854       finalize(i);
<a name="l00855"></a>00855       <span class="keywordflow">continue</span>;
<a name="l00856"></a>00856     }
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     <span class="keywordtype">float</span> cx = center_x(i);
<a name="l00859"></a>00859     <a class="code" href="class_t_b_o_x.html">TBOX</a> ibody(cx - 0.5 * row_pitch, 0, cx + 0.5 * row_pitch, 1);
<a name="l00860"></a>00860     <span class="keywordflow">if</span> (i &gt; 0) {
<a name="l00861"></a>00861       <span class="comment">// The preceding character significantly intersects with the</span>
<a name="l00862"></a>00862       <span class="comment">// imaginary body of this character. Let Pass2Analyze() handle</span>
<a name="l00863"></a>00863       <span class="comment">// this case.</span>
<a name="l00864"></a>00864       <span class="keywordflow">if</span> (x_overlap_fraction(ibody, box(i - 1)) &gt; 0.1) <span class="keywordflow">continue</span>;
<a name="l00865"></a>00865       <span class="keywordflow">if</span> (!is_final(i - 1)) {
<a name="l00866"></a>00866         <a class="code" href="class_t_b_o_x.html">TBOX</a> merged = box(i);
<a name="l00867"></a>00867         merged += box(i - 1);
<a name="l00868"></a>00868         <span class="keywordflow">if</span> (merged.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>() &lt; row_pitch) <span class="keywordflow">continue</span>;
<a name="l00869"></a>00869         <span class="comment">// This character cannot be finalized yet because it can be</span>
<a name="l00870"></a>00870         <span class="comment">// merged with the previous one.  Again, let Pass2Analyze()</span>
<a name="l00871"></a>00871         <span class="comment">// handle this case.</span>
<a name="l00872"></a>00872       }
<a name="l00873"></a>00873     }
<a name="l00874"></a>00874     <span class="keywordflow">if</span> (i &lt; num_chars() - 1) {
<a name="l00875"></a>00875       <span class="keywordflow">if</span> (x_overlap_fraction(ibody, box(i + 1)) &gt; 0.1) <span class="keywordflow">continue</span>;
<a name="l00876"></a>00876       <span class="keywordflow">if</span> (!is_final(i + 1)) {
<a name="l00877"></a>00877         <a class="code" href="class_t_b_o_x.html">TBOX</a> merged = box(i);
<a name="l00878"></a>00878         merged += box(i + 1);
<a name="l00879"></a>00879         <span class="keywordflow">if</span> (merged.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>() &lt; row_pitch) <span class="keywordflow">continue</span>;
<a name="l00880"></a>00880       }
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882     finalize(i);
<a name="l00883"></a>00883   }
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="comment">// Update alignment decision.  We only consider finalized characters</span>
<a name="l00886"></a>00886   <span class="comment">// in pass2.  E.g. if a finalized character C has another finalized</span>
<a name="l00887"></a>00887   <span class="comment">// character L on its left and a not-finalized character R on its</span>
<a name="l00888"></a>00888   <span class="comment">// right, we mark C as good if the pitch between C and L is good,</span>
<a name="l00889"></a>00889   <span class="comment">// regardless of the pitch between C and R.</span>
<a name="l00890"></a>00890   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_chars(); i++) {
<a name="l00891"></a>00891     <span class="keywordflow">if</span> (!is_final(i)) <span class="keywordflow">continue</span>;
<a name="l00892"></a>00892     <span class="keywordtype">bool</span> good_pitch = <span class="keyword">false</span>;
<a name="l00893"></a>00893     <span class="keywordtype">bool</span> bad_pitch = <span class="keyword">false</span>;
<a name="l00894"></a>00894     <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; is_final(i - 1)) {
<a name="l00895"></a>00895       <span class="keywordflow">if</span> (is_good_pitch(row_pitch, box(i - 1), box(i))) {
<a name="l00896"></a>00896         good_pitch = <span class="keyword">true</span>;
<a name="l00897"></a>00897       } <span class="keywordflow">else</span> {
<a name="l00898"></a>00898         bad_pitch = <span class="keyword">true</span>;
<a name="l00899"></a>00899       }
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901     <span class="keywordflow">if</span> (i &lt; num_chars() - 1 &amp;&amp; is_final(i + 1)) {
<a name="l00902"></a>00902       <span class="keywordflow">if</span> (is_good_pitch(row_pitch, box(i), box(i + 1))) {
<a name="l00903"></a>00903         good_pitch = <span class="keyword">true</span>;
<a name="l00904"></a>00904       } <span class="keywordflow">else</span> {
<a name="l00905"></a>00905         bad_pitch = <span class="keyword">true</span>;
<a name="l00906"></a>00906       }
<a name="l00907"></a>00907     }
<a name="l00908"></a>00908     <span class="keywordflow">if</span> (good_pitch &amp;&amp; !bad_pitch) mark_good(i);
<a name="l00909"></a>00909     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!good_pitch &amp;&amp; bad_pitch) mark_bad(i);
<a name="l00910"></a>00910   }
<a name="l00911"></a>00911 }
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 <span class="keyword">class </span>FPAnalyzer {
<a name="l00914"></a>00914  <span class="keyword">public</span>:
<a name="l00915"></a>00915   FPAnalyzer(): page_tr_(), rows_() { }
<a name="l00916"></a>00916   ~FPAnalyzer() { }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   <span class="keywordtype">void</span> Init(<a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> page_tr, TO_BLOCK_LIST *port_blocks);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920   <span class="keywordtype">void</span> Pass1Analyze() {
<a name="l00921"></a>00921     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) rows_[i].Pass1Analyze();
<a name="l00922"></a>00922   }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="comment">// Estimate character pitch for each row.  The argument pass1 can be</span>
<a name="l00925"></a>00925   <span class="comment">// set to true if the function is called after Pass1Analyze(), to</span>
<a name="l00926"></a>00926   <span class="comment">// eliminate some redundant computation.</span>
<a name="l00927"></a>00927   <span class="keywordtype">void</span> EstimatePitch(<span class="keywordtype">bool</span> pass1);
<a name="l00928"></a>00928 
<a name="l00929"></a>00929   <span class="keywordtype">bool</span> maybe_fixed_pitch() {
<a name="l00930"></a>00930     <span class="keywordflow">if</span> (rows_.empty() ||
<a name="l00931"></a>00931         rows_.size() &lt;= num_bad_rows_ + num_tall_rows_ + 1) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00932"></a>00932     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00933"></a>00933   }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935   <span class="keywordtype">void</span> MergeFragments() {
<a name="l00936"></a>00936     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) rows_[i].MergeFragments();
<a name="l00937"></a>00937   }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939   <span class="keywordtype">void</span> FinalizeLargeChars() {
<a name="l00940"></a>00940     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) rows_[i].FinalizeLargeChars();
<a name="l00941"></a>00941   }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943   <span class="keywordtype">bool</span> Pass2Analyze() {
<a name="l00944"></a>00944     <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;
<a name="l00945"></a>00945     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) {
<a name="l00946"></a>00946       <span class="keywordflow">if</span> (rows_[i].Pass2Analyze()) {
<a name="l00947"></a>00947         changed = <span class="keyword">true</span>;
<a name="l00948"></a>00948       }
<a name="l00949"></a>00949     }
<a name="l00950"></a>00950     <span class="keywordflow">return</span> changed;
<a name="l00951"></a>00951   }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953   <span class="keywordtype">void</span> OutputEstimations() {
<a name="l00954"></a>00954     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) rows_[i].OutputEstimations();
<a name="l00955"></a>00955     <span class="comment">// Don&#39;t we need page-level estimation of gaps/spaces?</span>
<a name="l00956"></a>00956   }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958   <span class="keywordtype">void</span> DebugOutputResult() {
<a name="l00959"></a>00959     <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;FPAnalyzer: final result\n&quot;</span>);
<a name="l00960"></a>00960     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) rows_[i].DebugOutputResult(i);
<a name="l00961"></a>00961   }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="keywordtype">int</span> num_rows() {
<a name="l00964"></a>00964     <span class="keywordflow">return</span> rows_.size();
<a name="l00965"></a>00965   }
<a name="l00966"></a>00966 
<a name="l00967"></a>00967   <span class="comment">// Returns the upper limit for pass2 loop iteration.</span>
<a name="l00968"></a>00968   <span class="keywordtype">int</span> max_iteration() {
<a name="l00969"></a>00969     <span class="comment">// We&#39;re fixing at least one character per iteration. So basically</span>
<a name="l00970"></a>00970     <span class="comment">// we shouldn&#39;t require more than max_chars_per_row_ iterations.</span>
<a name="l00971"></a>00971     <span class="keywordflow">return</span> max_chars_per_row_ + 100;
<a name="l00972"></a>00972   }
<a name="l00973"></a>00973 
<a name="l00974"></a>00974  <span class="keyword">private</span>:
<a name="l00975"></a>00975   <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> page_tr_;
<a name="l00976"></a>00976   <a class="code" href="class_generic_vector.html">GenericVector&lt;FPRow&gt;</a> rows_;
<a name="l00977"></a>00977   <span class="keywordtype">int</span> num_tall_rows_;
<a name="l00978"></a>00978   <span class="keywordtype">int</span> num_bad_rows_;
<a name="l00979"></a>00979   <span class="keywordtype">int</span> num_empty_rows_;
<a name="l00980"></a>00980   <span class="keywordtype">int</span> max_chars_per_row_;
<a name="l00981"></a>00981 };
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 <span class="keywordtype">void</span> FPAnalyzer::Init(<a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> page_tr, TO_BLOCK_LIST *port_blocks) {
<a name="l00984"></a>00984   page_tr_ = page_tr;
<a name="l00985"></a>00985 
<a name="l00986"></a>00986   TO_BLOCK_IT block_it;
<a name="l00987"></a>00987   block_it.set_to_list (port_blocks);
<a name="l00988"></a>00988 
<a name="l00989"></a>00989   <span class="keywordflow">for</span> (block_it.mark_cycle_pt(); !block_it.cycled_list();
<a name="l00990"></a>00990        block_it.forward()) {
<a name="l00991"></a>00991     <a class="code" href="class_t_o___b_l_o_c_k.html">TO_BLOCK</a> *block = block_it.data();
<a name="l00992"></a>00992     <span class="keywordflow">if</span> (!block-&gt;<a class="code" href="class_t_o___b_l_o_c_k.html#a4846ebdcc832b4b0a762d87c0d83a056">get_rows</a>()-&gt;empty()) {
<a name="l00993"></a>00993       <a class="code" href="errcode_8h.html#a93a603f4063a6b9403d81caa245a583b">ASSERT_HOST</a>(block-&gt;<a class="code" href="class_t_o___b_l_o_c_k.html#a4d0f99a557a4950af5123a31a157749f">xheight</a> &gt; 0);
<a name="l00994"></a>00994       <a class="code" href="topitch_8cpp.html#a9ecb24338e9f884525d31d89c309b216">find_repeated_chars</a>(block, <a class="code" href="host_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996   }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   num_empty_rows_ = 0;
<a name="l00999"></a>00999   max_chars_per_row_ = 0;
<a name="l01000"></a>01000   <span class="keywordflow">for</span> (block_it.mark_cycle_pt(); !block_it.cycled_list();
<a name="l01001"></a>01001        block_it.forward()) {
<a name="l01002"></a>01002     TO_ROW_IT row_it = block_it.data()-&gt;get_rows();
<a name="l01003"></a>01003     <span class="keywordflow">for</span> (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
<a name="l01004"></a>01004       FPRow row;
<a name="l01005"></a>01005       row.Init(row_it.data());
<a name="l01006"></a>01006       rows_.push_back(row);
<a name="l01007"></a>01007       <span class="keywordtype">int</span> num_chars = rows_.back().num_chars();
<a name="l01008"></a>01008       <span class="keywordflow">if</span> (num_chars &lt;= 1) num_empty_rows_++;
<a name="l01009"></a>01009       <span class="keywordflow">if</span> (num_chars &gt; max_chars_per_row_) max_chars_per_row_ = num_chars;
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011   }
<a name="l01012"></a>01012 }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="keywordtype">void</span> FPAnalyzer::EstimatePitch(<span class="keywordtype">bool</span> pass1) {
<a name="l01015"></a>01015   LocalCorrelation pitch_height_stats;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017   num_tall_rows_ = 0;
<a name="l01018"></a>01018   num_bad_rows_ = 0;
<a name="l01019"></a>01019   pitch_height_stats.Clear();
<a name="l01020"></a>01020   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) {
<a name="l01021"></a>01021     rows_[i].EstimatePitch(pass1);
<a name="l01022"></a>01022     <span class="keywordflow">if</span> (rows_[i].good_pitches()) {
<a name="l01023"></a>01023       pitch_height_stats.Add(rows_[i].height() + rows_[i].gap(),
<a name="l01024"></a>01024                              rows_[i].pitch(), rows_[i].good_pitches());
<a name="l01025"></a>01025       <span class="keywordflow">if</span> (rows_[i].height_pitch_ratio() &gt; 1.1) num_tall_rows_++;
<a name="l01026"></a>01026     } <span class="keywordflow">else</span> {
<a name="l01027"></a>01027       num_bad_rows_++;
<a name="l01028"></a>01028     }
<a name="l01029"></a>01029   }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031   pitch_height_stats.Finish();
<a name="l01032"></a>01032   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows_.size(); i++) {
<a name="l01033"></a>01033     <span class="keywordflow">if</span> (rows_[i].good_pitches() &gt;= 5) {
<a name="l01034"></a>01034       <span class="comment">// We have enough evidences. Just use the pitch estimation</span>
<a name="l01035"></a>01035       <span class="comment">// from this row.</span>
<a name="l01036"></a>01036       rows_[i].set_estimated_pitch(rows_[i].pitch());
<a name="l01037"></a>01037     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rows_[i].num_chars() &gt; 1) {
<a name="l01038"></a>01038       <span class="keywordtype">float</span> estimated_pitch =
<a name="l01039"></a>01039           pitch_height_stats.EstimateYFor(rows_[i].height() + rows_[i].gap(),
<a name="l01040"></a>01040                                           0.1);
<a name="l01041"></a>01041       <span class="comment">// CJK characters are more likely to be fragmented than poorly</span>
<a name="l01042"></a>01042       <span class="comment">// chopped. So trust the page-level estimation of character</span>
<a name="l01043"></a>01043       <span class="comment">// pitch only if it&#39;s larger than row-level estimation or</span>
<a name="l01044"></a>01044       <span class="comment">// row-level estimation is too large (2x bigger than row height).</span>
<a name="l01045"></a>01045       <span class="keywordflow">if</span> (estimated_pitch &gt; rows_[i].pitch() ||
<a name="l01046"></a>01046           rows_[i].pitch() &gt; rows_[i].height() * 2.0) {
<a name="l01047"></a>01047         rows_[i].set_estimated_pitch(estimated_pitch);
<a name="l01048"></a>01048       } <span class="keywordflow">else</span> {
<a name="l01049"></a>01049         rows_[i].set_estimated_pitch(rows_[i].pitch());
<a name="l01050"></a>01050       }
<a name="l01051"></a>01051     }
<a name="l01052"></a>01052   }
<a name="l01053"></a>01053 }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 }  <span class="comment">// namespace</span>
<a name="l01056"></a>01056 
<a name="l01057"></a><a class="code" href="cjkpitch_8h.html#a569376d5bd104938452ead2e78c21158">01057</a> <span class="keywordtype">void</span> <a class="code" href="cjkpitch_8cpp.html#a569376d5bd104938452ead2e78c21158">compute_fixed_pitch_cjk</a>(<a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> page_tr,
<a name="l01058"></a>01058                              TO_BLOCK_LIST *port_blocks) {
<a name="l01059"></a>01059   FPAnalyzer analyzer;
<a name="l01060"></a>01060   analyzer.Init(page_tr, port_blocks);
<a name="l01061"></a>01061   <span class="keywordflow">if</span> (analyzer.num_rows() == 0) <span class="keywordflow">return</span>;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063   analyzer.Pass1Analyze();
<a name="l01064"></a>01064   analyzer.EstimatePitch(<span class="keyword">true</span>);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066   <span class="comment">// Perform pass1 analysis again with the initial estimation of row</span>
<a name="l01067"></a>01067   <span class="comment">// pitches, for better estimation.</span>
<a name="l01068"></a>01068   analyzer.Pass1Analyze();
<a name="l01069"></a>01069   analyzer.EstimatePitch(<span class="keyword">true</span>);
<a name="l01070"></a>01070 
<a name="l01071"></a>01071   <span class="comment">// Early exit if the page doesn&#39;t seem to contain fixed pitch rows.</span>
<a name="l01072"></a>01072   <span class="keywordflow">if</span> (!analyzer.maybe_fixed_pitch()) {
<a name="l01073"></a>01073     <span class="keywordflow">if</span> (<a class="code" href="topitch_8cpp.html#ad764b0bdba3585a8abdceb60288e54f0">textord_debug_pitch_test</a>) {
<a name="l01074"></a>01074       <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;Page doesn&#39;t seem to contain fixed pitch rows\n&quot;</span>);
<a name="l01075"></a>01075     }
<a name="l01076"></a>01076     <span class="keywordflow">return</span>;
<a name="l01077"></a>01077   }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   <span class="keywordtype">int</span> iteration = 0;
<a name="l01080"></a>01080   <span class="keywordflow">do</span> {
<a name="l01081"></a>01081     analyzer.MergeFragments();
<a name="l01082"></a>01082     analyzer.FinalizeLargeChars();
<a name="l01083"></a>01083     analyzer.EstimatePitch(<span class="keyword">false</span>);
<a name="l01084"></a>01084     iteration++;
<a name="l01085"></a>01085   } <span class="keywordflow">while</span> (analyzer.Pass2Analyze() &amp;&amp; iteration &lt; analyzer.max_iteration());
<a name="l01086"></a>01086 
<a name="l01087"></a>01087   <span class="keywordflow">if</span> (<a class="code" href="topitch_8cpp.html#ad764b0bdba3585a8abdceb60288e54f0">textord_debug_pitch_test</a>) {
<a name="l01088"></a>01088     <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;compute_fixed_pitch_cjk finished after %d iteration (limit=%d)\n&quot;</span>,
<a name="l01089"></a>01089             iteration, analyzer.max_iteration());
<a name="l01090"></a>01090   }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092   analyzer.OutputEstimations();
<a name="l01093"></a>01093   <span class="keywordflow">if</span> (<a class="code" href="topitch_8cpp.html#ad764b0bdba3585a8abdceb60288e54f0">textord_debug_pitch_test</a>) analyzer.DebugOutputResult();
<a name="l01094"></a>01094 }
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="cjkpitch_8cpp.html">cjkpitch.cpp</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Mar 29 2012 23:42:12 for Tesseract by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
