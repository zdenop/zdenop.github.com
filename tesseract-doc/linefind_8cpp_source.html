<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Tesseract: tesseract-ocr/textord/linefind.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tesseract
   &#160;<span id="projectnumber">3.02</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('linefind_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tesseract-ocr/textord/linefind.cpp</div>  </div>
</div>
<div class="contents">
<a href="linefind_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">// File:        linefind.cpp</span>
<a name="l00003"></a>00003 <span class="comment">// Description: Class to find vertical lines in an image and create</span>
<a name="l00004"></a>00004 <span class="comment">//              a corresponding list of empty blobs.</span>
<a name="l00005"></a>00005 <span class="comment">// Author:      Ray Smith</span>
<a name="l00006"></a>00006 <span class="comment">// Created:     Thu Mar 20 09:49:01 PDT 2008</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">// (C) Copyright 2008, Google Inc.</span>
<a name="l00009"></a>00009 <span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<a name="l00010"></a>00010 <span class="comment">// you may not use this file except in compliance with the License.</span>
<a name="l00011"></a>00011 <span class="comment">// You may obtain a copy of the License at</span>
<a name="l00012"></a>00012 <span class="comment">// http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00013"></a>00013 <span class="comment">// Unless required by applicable law or agreed to in writing, software</span>
<a name="l00014"></a>00014 <span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<a name="l00015"></a>00015 <span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<a name="l00016"></a>00016 <span class="comment">// See the License for the specific language governing permissions and</span>
<a name="l00017"></a>00017 <span class="comment">// limitations under the License.</span>
<a name="l00018"></a>00018 <span class="comment">//</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable:4244)  // Conversion warnings</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="linefind_8h.html">linefind.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="alignedblob_8h.html">alignedblob.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="tabvector_8h.html">tabvector.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="blobbox_8h.html">blobbox.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="edgblob_8h.html">edgblob.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="comment">// This entire file is dependent upon leptonica. If you don&#39;t have it,</span>
<a name="l00031"></a>00031 <span class="comment">// then the code doesn&#39;t do anything useful.</span>
<a name="l00032"></a>00032 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="config__auto_8h.html">config_auto.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#include &quot;allheaders.h&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keyword">namespace </span>tesseract {
<a name="l00038"></a>00038 
<a name="l00040"></a><a class="code" href="namespacetesseract.html#af5a3375be81da4b1d09d654fed77617a">00040</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesseract.html#af5a3375be81da4b1d09d654fed77617a" title="Denominator of resolution makes max pixel width to allow thin lines.">kThinLineFraction</a> = 20;
<a name="l00042"></a><a class="code" href="namespacetesseract.html#ab1ecce6329628c52853d15330697b9a5">00042</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesseract.html#ab1ecce6329628c52853d15330697b9a5" title="Denominator of resolution makes min pixels to demand line lengths to be.">kMinLineLengthFraction</a> = 4;
<a name="l00044"></a><a class="code" href="namespacetesseract.html#a67e1606288499ff9e08833b9c2a1ded8">00044</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesseract.html#a67e1606288499ff9e08833b9c2a1ded8" title="Spacing of cracks across the page to break up tall vertical lines.">kCrackSpacing</a> = 100;
<a name="l00046"></a><a class="code" href="namespacetesseract.html#acbcf973384ce439c1b3ab4decf0c383c">00046</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesseract.html#acbcf973384ce439c1b3ab4decf0c383c" title="Grid size used by line finder. Not very critical.">kLineFindGridSize</a> = 50;
<a name="l00047"></a>00047 <span class="comment">// Min width of a line in pixels to be considered thick.</span>
<a name="l00048"></a><a class="code" href="namespacetesseract.html#a8109c0293738c5b8a499baf96e6191e2">00048</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesseract.html#a8109c0293738c5b8a499baf96e6191e2">kMinThickLineWidth</a> = 12;
<a name="l00049"></a>00049 <span class="comment">// Max size of line residue. (The pixels that fail the long thin opening, and</span>
<a name="l00050"></a>00050 <span class="comment">// therefore don&#39;t make it to the candidate line mask, but are nevertheless</span>
<a name="l00051"></a>00051 <span class="comment">// part of the line.)</span>
<a name="l00052"></a><a class="code" href="namespacetesseract.html#ab97d7447e46667c618a568b97b96bb3c">00052</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesseract.html#ab97d7447e46667c618a568b97b96bb3c">kMaxLineResidue</a> = 6;
<a name="l00053"></a>00053 <span class="comment">// Min length in inches of a line segment that exceeds kMinThickLineWidth in</span>
<a name="l00054"></a>00054 <span class="comment">// thickness. (Such lines shouldn&#39;t break by simple image degradation.)</span>
<a name="l00055"></a><a class="code" href="namespacetesseract.html#a6978c95cbd05d6aef11ca4b7850a1a6b">00055</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacetesseract.html#a6978c95cbd05d6aef11ca4b7850a1a6b">kThickLengthMultiple</a> = 0.75;
<a name="l00056"></a>00056 <span class="comment">// Max fraction of line box area that can be occupied by non-line pixels.</span>
<a name="l00057"></a><a class="code" href="namespacetesseract.html#a88f852ceee95241622ec0f837dbfeff8">00057</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacetesseract.html#a88f852ceee95241622ec0f837dbfeff8">kMaxNonLineDensity</a> = 0.25;
<a name="l00058"></a>00058 <span class="comment">// Max height of a music stave in inches.</span>
<a name="l00059"></a><a class="code" href="namespacetesseract.html#a40e2e4747be3bc8a6358a023e2e3a001">00059</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacetesseract.html#a40e2e4747be3bc8a6358a023e2e3a001">kMaxStaveHeight</a> = 1.0;
<a name="l00060"></a>00060 <span class="comment">// Minimum fraction of pixels in a music rectangle connected to the staves.</span>
<a name="l00061"></a><a class="code" href="namespacetesseract.html#a064746ea8b34175e6f12ce364c8d6414">00061</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacetesseract.html#a064746ea8b34175e6f12ce364c8d6414">kMinMusicPixelFraction</a> = 0.75;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">// Erases the unused blobs from the line_pix image, taking into account</span>
<a name="l00064"></a>00064 <span class="comment">// whether this was a horizontal or vertical line set.</span>
<a name="l00065"></a>00065 <span class="keyword">static</span> <span class="keywordtype">void</span> RemoveUnusedLineSegments(<span class="keywordtype">bool</span> horizontal_lines,
<a name="l00066"></a>00066                                      BLOBNBOX_LIST* line_bblobs,
<a name="l00067"></a>00067                                      Pix* line_pix) {
<a name="l00068"></a>00068   <span class="keywordtype">int</span> height = pixGetHeight(line_pix);
<a name="l00069"></a>00069   BLOBNBOX_IT bbox_it(line_bblobs);
<a name="l00070"></a>00070   <span class="keywordflow">for</span> (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
<a name="l00071"></a>00071     <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a>* blob = bbox_it.data();
<a name="l00072"></a>00072     <span class="keywordflow">if</span> (blob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a8b16d77deb75ed8aa2ff9d6be9462ec1">left_tab_type</a>() == <a class="code" href="blobbox_8h.html#a6d0b33e703e1291d0b60d4fe5a5e12ccad0945333210420da84a7617b5788f246">TT_MAYBE_ALIGNED</a>) {
<a name="l00073"></a>00073       <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box = blob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a7b97b8bc16b1473a28f9c44011522f4e">bounding_box</a>();
<a name="l00074"></a>00074       Box* pixbox = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00075"></a>00075       <span class="keywordflow">if</span> (horizontal_lines) {
<a name="l00076"></a>00076         <span class="comment">// Horizontal lines are in tess format and also have x and y flipped</span>
<a name="l00077"></a>00077         <span class="comment">// (to use FindVerticalAlignment) so we have to flip x and y and then</span>
<a name="l00078"></a>00078         <span class="comment">// convert to Leptonica by height - flipped x (ie the right edge).</span>
<a name="l00079"></a>00079         <span class="comment">// See GetLineBoxes for more explanation.</span>
<a name="l00080"></a>00080         pixbox = boxCreate(box.<a class="code" href="class_t_b_o_x.html#a4451d237f1cd18c4982d63fe36a11fc3">bottom</a>(), height - box.<a class="code" href="class_t_b_o_x.html#a8703081c1a1c26db3a4dddaca1028e34">right</a>(),
<a name="l00081"></a>00081                            box.<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>(), box.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>());
<a name="l00082"></a>00082 
<a name="l00083"></a>00083       } <span class="keywordflow">else</span> {
<a name="l00084"></a>00084         <span class="comment">// For vertical lines, just flip upside-down to convert to Leptonica.</span>
<a name="l00085"></a>00085         <span class="comment">// The y position of the box in Leptonica terms is the distance from</span>
<a name="l00086"></a>00086         <span class="comment">// the top of the image to the top of the box.</span>
<a name="l00087"></a>00087         pixbox = boxCreate(box.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>(), height - box.<a class="code" href="class_t_b_o_x.html#adf92e9fdac1bdf11c10d1c4d1178791a">top</a>(),
<a name="l00088"></a>00088                            box.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>(), box.<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>());
<a name="l00089"></a>00089       }
<a name="l00090"></a>00090       pixClearInRect(line_pix, pixbox);
<a name="l00091"></a>00091       boxDestroy(&amp;pixbox);
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093   }
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="comment">// Helper subtracts the line_pix image from the src_pix, and removes residue</span>
<a name="l00097"></a>00097 <span class="comment">// as well by removing components that touch the line, but are not in the</span>
<a name="l00098"></a>00098 <span class="comment">// non_line_pix mask. It is assumed that the non_line_pix mask has already</span>
<a name="l00099"></a>00099 <span class="comment">// been prepared to required accuracy.</span>
<a name="l00100"></a>00100 <span class="keyword">static</span> <span class="keywordtype">void</span> SubtractLinesAndResidue(Pix* line_pix, Pix* non_line_pix,
<a name="l00101"></a>00101                                     <span class="keywordtype">int</span> resolution, Pix* src_pix) {
<a name="l00102"></a>00102   <span class="comment">// First remove the lines themselves.</span>
<a name="l00103"></a>00103   pixSubtract(src_pix, src_pix, line_pix);
<a name="l00104"></a>00104   <span class="comment">// Subtract the non-lines from the image to get the residue.</span>
<a name="l00105"></a>00105   Pix* residue_pix = pixSubtract(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, src_pix, non_line_pix);
<a name="l00106"></a>00106   <span class="comment">// Dilate the lines so they touch the residue.</span>
<a name="l00107"></a>00107   Pix* fat_line_pix = pixDilateBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, line_pix, 3, 3);
<a name="l00108"></a>00108   <span class="comment">// Seed fill the fat lines to get all the residue.</span>
<a name="l00109"></a>00109   pixSeedfillBinary(fat_line_pix, fat_line_pix, residue_pix, 8);
<a name="l00110"></a>00110   <span class="comment">// Subtract the residue from the original image.</span>
<a name="l00111"></a>00111   pixSubtract(src_pix, src_pix, fat_line_pix);
<a name="l00112"></a>00112   pixDestroy(&amp;fat_line_pix);
<a name="l00113"></a>00113   pixDestroy(&amp;residue_pix);
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment">// Returns the maximum strokewidth in the given binary image by doubling</span>
<a name="l00117"></a>00117 <span class="comment">// the maximum of the distance function.</span>
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keywordtype">int</span> MaxStrokeWidth(Pix* pix) {
<a name="l00119"></a>00119   Pix* dist_pix = pixDistanceFunction(pix, 4, 8, L_BOUNDARY_BG);
<a name="l00120"></a>00120   <span class="keywordtype">int</span> width = pixGetWidth(dist_pix);
<a name="l00121"></a>00121   <span class="keywordtype">int</span> height = pixGetHeight(dist_pix);
<a name="l00122"></a>00122   <span class="keywordtype">int</span> wpl = pixGetWpl(dist_pix);
<a name="l00123"></a>00123   l_uint32* data = pixGetData(dist_pix);
<a name="l00124"></a>00124   <span class="comment">// Find the maximum value in the distance image.</span>
<a name="l00125"></a>00125   <span class="keywordtype">int</span> max_dist = 0;
<a name="l00126"></a>00126   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; ++y) {
<a name="l00127"></a>00127     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; ++x) {
<a name="l00128"></a>00128       <span class="keywordtype">int</span> pixel = GET_DATA_BYTE(data, x);
<a name="l00129"></a>00129       <span class="keywordflow">if</span> (pixel &gt; max_dist)
<a name="l00130"></a>00130         max_dist = pixel;
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132     data += wpl;
<a name="l00133"></a>00133   }
<a name="l00134"></a>00134   pixDestroy(&amp;dist_pix);
<a name="l00135"></a>00135   <span class="keywordflow">return</span> max_dist * 2;
<a name="l00136"></a>00136 }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="comment">// Returns the number of components in the intersection_pix touched by line_box.</span>
<a name="l00139"></a>00139 <span class="keyword">static</span> <span class="keywordtype">int</span> NumTouchingIntersections(Box* line_box, Pix* intersection_pix) {
<a name="l00140"></a>00140   <span class="keywordflow">if</span> (intersection_pix == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> 0;
<a name="l00141"></a>00141   Pix* rect_pix = pixClipRectangle(intersection_pix, line_box, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00142"></a>00142   Boxa* boxa = pixConnComp(rect_pix, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 8);
<a name="l00143"></a>00143   pixDestroy(&amp;rect_pix);
<a name="l00144"></a>00144   <span class="keywordflow">if</span> (boxa == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00145"></a>00145   <span class="keywordtype">int</span> result = boxaGetCount(boxa);
<a name="l00146"></a>00146   boxaDestroy(&amp;boxa);
<a name="l00147"></a>00147   <span class="keywordflow">return</span> result;
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">// Returns the number of black pixels found in the box made by adding the line</span>
<a name="l00151"></a>00151 <span class="comment">// width to both sides of the line bounding box. (Increasing the smallest</span>
<a name="l00152"></a>00152 <span class="comment">// dimension of the bounding box.)</span>
<a name="l00153"></a>00153 <span class="keyword">static</span> <span class="keywordtype">int</span> CountPixelsAdjacentToLine(<span class="keywordtype">int</span> line_width, Box* line_box,
<a name="l00154"></a>00154                                      Pix* nonline_pix) {
<a name="l00155"></a>00155   l_int32 x, y, box_width, box_height;
<a name="l00156"></a>00156   boxGetGeometry(line_box, &amp;x, &amp;y, &amp;box_width, &amp;box_height);
<a name="l00157"></a>00157   <span class="keywordflow">if</span> (box_width &gt; box_height) {
<a name="l00158"></a>00158     <span class="comment">// horizontal line.</span>
<a name="l00159"></a>00159     <span class="keywordtype">int</span> bottom = <a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>(pixGetHeight(nonline_pix), y + box_height + line_width);
<a name="l00160"></a>00160     y = <a class="code" href="ndminx_8h.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(0, y - line_width);
<a name="l00161"></a>00161     box_height = bottom - y;
<a name="l00162"></a>00162   } <span class="keywordflow">else</span> {
<a name="l00163"></a>00163     <span class="comment">// Vertical line.</span>
<a name="l00164"></a>00164     <span class="keywordtype">int</span> right = <a class="code" href="ndminx_8h.html#a74e75242132eaabbc1c512488a135926">MIN</a>(pixGetWidth(nonline_pix), x + box_width + line_width);
<a name="l00165"></a>00165     x = <a class="code" href="ndminx_8h.html#aacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(0, x - line_width);
<a name="l00166"></a>00166     box_width = right - x;
<a name="l00167"></a>00167   }
<a name="l00168"></a>00168   Box* box = boxCreate(x, y, box_width, box_height);
<a name="l00169"></a>00169   Pix* rect_pix = pixClipRectangle(nonline_pix, box, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00170"></a>00170   boxDestroy(&amp;box);
<a name="l00171"></a>00171   l_int32 result;
<a name="l00172"></a>00172   pixCountPixels(rect_pix, &amp;result, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00173"></a>00173   pixDestroy(&amp;rect_pix);
<a name="l00174"></a>00174   <span class="keywordflow">return</span> result;
<a name="l00175"></a>00175 }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="comment">// Helper erases false-positive line segments from the input/output line_pix.</span>
<a name="l00178"></a>00178 <span class="comment">// 1. Since thick lines shouldn&#39;t really break up, we can eliminate some false</span>
<a name="l00179"></a>00179 <span class="comment">//    positives by marking segments that are at least kMinThickLineWidth</span>
<a name="l00180"></a>00180 <span class="comment">//    thickness, yet have a length less than min_thick_length.</span>
<a name="l00181"></a>00181 <span class="comment">// 2. Lines that don&#39;t have at least 2 intersections with other lines and have</span>
<a name="l00182"></a>00182 <span class="comment">//    a lot of neighbouring non-lines are probably not lines (perhaps arabic</span>
<a name="l00183"></a>00183 <span class="comment">//    or Hindi words, or underlines.)</span>
<a name="l00184"></a>00184 <span class="comment">// Bad line components are erased from line_pix.</span>
<a name="l00185"></a>00185 <span class="comment">// Returns the number of remaining connected components.</span>
<a name="l00186"></a>00186 <span class="keyword">static</span> <span class="keywordtype">int</span> FilterFalsePositives(<span class="keywordtype">int</span> resolution, Pix* nonline_pix,
<a name="l00187"></a>00187                                 Pix* intersection_pix, Pix* line_pix) {
<a name="l00188"></a>00188   <span class="keywordtype">int</span> min_thick_length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(resolution * <a class="code" href="namespacetesseract.html#a6978c95cbd05d6aef11ca4b7850a1a6b">kThickLengthMultiple</a>);
<a name="l00189"></a>00189   Pixa* pixa = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00190"></a>00190   Boxa* boxa = pixConnComp(line_pix, &amp;pixa, 8);
<a name="l00191"></a>00191   <span class="comment">// Iterate over the boxes to remove false positives.</span>
<a name="l00192"></a>00192   <span class="keywordtype">int</span> nboxes = boxaGetCount(boxa);
<a name="l00193"></a>00193   <span class="keywordtype">int</span> remaining_boxes = nboxes;
<a name="l00194"></a>00194   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nboxes; ++i) {
<a name="l00195"></a>00195     Box* box = boxaGetBox(boxa, i, L_CLONE);
<a name="l00196"></a>00196     l_int32 x, y, box_width, box_height;
<a name="l00197"></a>00197     boxGetGeometry(box, &amp;x, &amp;y, &amp;box_width, &amp;box_height);
<a name="l00198"></a>00198     Pix* comp_pix = pixaGetPix(pixa, i, L_CLONE);
<a name="l00199"></a>00199     <span class="keywordtype">int</span> max_width = MaxStrokeWidth(comp_pix);
<a name="l00200"></a>00200     pixDestroy(&amp;comp_pix);
<a name="l00201"></a>00201     <span class="keywordtype">bool</span> bad_line = <span class="keyword">false</span>;
<a name="l00202"></a>00202     <span class="comment">// If the length is too short to stand-alone as a line, and the box width</span>
<a name="l00203"></a>00203     <span class="comment">// is thick enough, and the stroke width is thick enough it is bad.</span>
<a name="l00204"></a>00204     <span class="keywordflow">if</span> (box_width &gt;= <a class="code" href="namespacetesseract.html#a8109c0293738c5b8a499baf96e6191e2">kMinThickLineWidth</a> &amp;&amp; box_height &gt;= <a class="code" href="namespacetesseract.html#a8109c0293738c5b8a499baf96e6191e2">kMinThickLineWidth</a> &amp;&amp;
<a name="l00205"></a>00205         box_width &lt; min_thick_length &amp;&amp; box_height &lt; min_thick_length &amp;&amp;
<a name="l00206"></a>00206         max_width &gt; <a class="code" href="namespacetesseract.html#a8109c0293738c5b8a499baf96e6191e2">kMinThickLineWidth</a>) {
<a name="l00207"></a>00207       <span class="comment">// Too thick for the length.</span>
<a name="l00208"></a>00208       bad_line = <span class="keyword">true</span>;
<a name="l00209"></a>00209     }
<a name="l00210"></a>00210     <span class="keywordflow">if</span> (!bad_line &amp;&amp;
<a name="l00211"></a>00211         (intersection_pix == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> ||
<a name="l00212"></a>00212         NumTouchingIntersections(box, intersection_pix) &lt; 2)) {
<a name="l00213"></a>00213       <span class="comment">// Test non-line density near the line.</span>
<a name="l00214"></a>00214       <span class="keywordtype">int</span> nonline_count = CountPixelsAdjacentToLine(max_width, box,
<a name="l00215"></a>00215                                                     nonline_pix);
<a name="l00216"></a>00216       <span class="keywordflow">if</span> (nonline_count &gt; box_height * box_width * <a class="code" href="namespacetesseract.html#a88f852ceee95241622ec0f837dbfeff8">kMaxNonLineDensity</a>)
<a name="l00217"></a>00217         bad_line = <span class="keyword">true</span>;
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219     <span class="keywordflow">if</span> (bad_line) {
<a name="l00220"></a>00220       <span class="comment">// Not a good line.</span>
<a name="l00221"></a>00221       pixClearInRect(line_pix, box);
<a name="l00222"></a>00222       --remaining_boxes;
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224     boxDestroy(&amp;box);
<a name="l00225"></a>00225   }
<a name="l00226"></a>00226   pixaDestroy(&amp;pixa);
<a name="l00227"></a>00227   boxaDestroy(&amp;boxa);
<a name="l00228"></a>00228   <span class="keywordflow">return</span> remaining_boxes;
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="comment">// Finds vertical and horizontal line objects in the given pix.</span>
<a name="l00232"></a>00232 <span class="comment">// Uses the given resolution to determine size thresholds instead of any</span>
<a name="l00233"></a>00233 <span class="comment">// that may be present in the pix.</span>
<a name="l00234"></a>00234 <span class="comment">// The output vertical_x and vertical_y contain a sum of the output vectors,</span>
<a name="l00235"></a>00235 <span class="comment">// thereby giving the mean vertical direction.</span>
<a name="l00236"></a>00236 <span class="comment">// If pix_music_mask != NULL, and music is detected, a mask of the staves</span>
<a name="l00237"></a>00237 <span class="comment">// and anything that is connected (bars, notes etc.) will be returned in</span>
<a name="l00238"></a>00238 <span class="comment">// pix_music_mask, the mask subtracted from pix, and the lines will not</span>
<a name="l00239"></a>00239 <span class="comment">// appear in v_lines or h_lines.</span>
<a name="l00240"></a>00240 <span class="comment">// The output vectors are owned by the list and Frozen (cannot refit) by</span>
<a name="l00241"></a>00241 <span class="comment">// having no boxes, as there is no need to refit or merge separator lines.</span>
<a name="l00242"></a>00242 <span class="comment">// The detected lines are removed from the pix.</span>
<a name="l00243"></a><a class="code" href="classtesseract_1_1_line_finder.html#a3a72521c00cb7725b2282b7b3cc6e6b9">00243</a> <span class="keywordtype">void</span> <a class="code" href="classtesseract_1_1_line_finder.html#a3a72521c00cb7725b2282b7b3cc6e6b9">LineFinder::FindAndRemoveLines</a>(<span class="keywordtype">int</span> resolution, <span class="keywordtype">bool</span> debug, Pix* pix,
<a name="l00244"></a>00244                                     <span class="keywordtype">int</span>* vertical_x, <span class="keywordtype">int</span>* vertical_y,
<a name="l00245"></a>00245                                     Pix** pix_music_mask,
<a name="l00246"></a>00246                                     TabVector_LIST* v_lines,
<a name="l00247"></a>00247                                     TabVector_LIST* h_lines) {
<a name="l00248"></a>00248   <span class="keywordflow">if</span> (pix == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || vertical_x == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || vertical_y == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00249"></a>00249     <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;Error in parameters for LineFinder::FindAndRemoveLines\n&quot;</span>);
<a name="l00250"></a>00250     <span class="keywordflow">return</span>;
<a name="l00251"></a>00251   }
<a name="l00252"></a>00252   Pix* pix_vline = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00253"></a>00253   Pix* pix_non_vline = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00254"></a>00254   Pix* pix_hline = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00255"></a>00255   Pix* pix_non_hline = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00256"></a>00256   Pix* pix_intersections = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00257"></a>00257   Pixa* pixa_display = debug ? pixaCreate(0) : <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00258"></a>00258   GetLineMasks(resolution, pix, &amp;pix_vline, &amp;pix_non_vline, &amp;pix_hline,
<a name="l00259"></a>00259                &amp;pix_non_hline, &amp;pix_intersections, pix_music_mask,
<a name="l00260"></a>00260                pixa_display);
<a name="l00261"></a>00261   <span class="comment">// Find lines, convert to TabVector_LIST and remove those that are used.</span>
<a name="l00262"></a>00262   FindAndRemoveVLines(resolution, pix_intersections, vertical_x, vertical_y,
<a name="l00263"></a>00263                       &amp;pix_vline, pix_non_vline, pix, v_lines);
<a name="l00264"></a>00264   <span class="keywordflow">if</span> (pix_hline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00265"></a>00265     <span class="comment">// Recompute intersections and re-filter false positive h-lines.</span>
<a name="l00266"></a>00266     <span class="keywordflow">if</span> (pix_vline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00267"></a>00267       pixAnd(pix_intersections, pix_vline, pix_hline);
<a name="l00268"></a>00268     <span class="keywordflow">else</span>
<a name="l00269"></a>00269       pixDestroy(&amp;pix_intersections);
<a name="l00270"></a>00270     <span class="keywordflow">if</span> (!FilterFalsePositives(resolution, pix_non_hline, pix_intersections,
<a name="l00271"></a>00271                               pix_hline)) {
<a name="l00272"></a>00272       pixDestroy(&amp;pix_hline);
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274   }
<a name="l00275"></a>00275   FindAndRemoveHLines(resolution, pix_intersections, *vertical_x, *vertical_y,
<a name="l00276"></a>00276                       &amp;pix_hline, pix_non_hline, pix, h_lines);
<a name="l00277"></a>00277   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; pix_vline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00278"></a>00278     pixaAddPix(pixa_display, pix_vline, L_CLONE);
<a name="l00279"></a>00279   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; pix_hline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00280"></a>00280     pixaAddPix(pixa_display, pix_hline, L_CLONE);
<a name="l00281"></a>00281   <span class="keywordflow">if</span> (pix_vline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; pix_hline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00282"></a>00282     <span class="comment">// Remove joins (intersections) where lines cross, and the residue.</span>
<a name="l00283"></a>00283     <span class="comment">// Recalculate the intersections, since some lines have been deleted.</span>
<a name="l00284"></a>00284     pixAnd(pix_intersections, pix_vline, pix_hline);
<a name="l00285"></a>00285     <span class="comment">// Fatten up the intersections and seed-fill to get the intersection</span>
<a name="l00286"></a>00286     <span class="comment">// residue.</span>
<a name="l00287"></a>00287     Pix* pix_join_residue = pixDilateBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_intersections, 5, 5);
<a name="l00288"></a>00288     pixSeedfillBinary(pix_join_residue, pix_join_residue, pix, 8);
<a name="l00289"></a>00289     <span class="comment">// Now remove the intersection residue.</span>
<a name="l00290"></a>00290     pixSubtract(pix, pix, pix_join_residue);
<a name="l00291"></a>00291     pixDestroy(&amp;pix_join_residue);
<a name="l00292"></a>00292   }
<a name="l00293"></a>00293   <span class="comment">// Remove any detected music.</span>
<a name="l00294"></a>00294   <span class="keywordflow">if</span> (pix_music_mask != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; *pix_music_mask != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00295"></a>00295     <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00296"></a>00296       pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
<a name="l00297"></a>00297     pixSubtract(pix, pix, *pix_music_mask);
<a name="l00298"></a>00298   }
<a name="l00299"></a>00299   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00300"></a>00300     pixaAddPix(pixa_display, pix, L_CLONE);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   pixDestroy(&amp;pix_vline);
<a name="l00303"></a>00303   pixDestroy(&amp;pix_non_vline);
<a name="l00304"></a>00304   pixDestroy(&amp;pix_hline);
<a name="l00305"></a>00305   pixDestroy(&amp;pix_non_hline);
<a name="l00306"></a>00306   pixDestroy(&amp;pix_intersections);
<a name="l00307"></a>00307   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00308"></a>00308 <span class="preprocessor">#if LIBLEPT_MINOR_VERSION &gt;= 69 || LIBLEPT_MAJOR_VERSION &gt; 1</span>
<a name="l00309"></a>00309 <span class="preprocessor"></span>    pixaConvertToPdf(pixa_display, resolution, 1.0<a class="code" href="imgscale_8cpp.html#a469169df397b589e709dc744f1346831">f</a>, 0, 0, <span class="stringliteral">&quot;LineFinding&quot;</span>,
<a name="l00310"></a>00310                      <span class="stringliteral">&quot;vhlinefinding.pdf&quot;</span>);
<a name="l00311"></a>00311 <span class="preprocessor">#endif</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span>    pixaDestroy(&amp;pixa_display);
<a name="l00313"></a>00313   }
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">// Converts the Boxa array to a list of C_BLOB, getting rid of severely</span>
<a name="l00317"></a>00317 <span class="comment">// overlapping outlines and those that are children of a bigger one.</span>
<a name="l00318"></a>00318 <span class="comment">// The output is a list of C_BLOBs that are owned by the list.</span>
<a name="l00319"></a>00319 <span class="comment">// The C_OUTLINEs in the C_BLOBs contain no outline data - just empty</span>
<a name="l00320"></a>00320 <span class="comment">// bounding boxes. The Boxa is consumed and destroyed.</span>
<a name="l00321"></a><a class="code" href="classtesseract_1_1_line_finder.html#a9d00a88e3c4d6e1b9c7b28c3f6825b88">00321</a> <span class="keywordtype">void</span> <a class="code" href="classtesseract_1_1_line_finder.html#a9d00a88e3c4d6e1b9c7b28c3f6825b88">LineFinder::ConvertBoxaToBlobs</a>(<span class="keywordtype">int</span> image_width, <span class="keywordtype">int</span> image_height,
<a name="l00322"></a>00322                                     Boxa** boxes, C_BLOB_LIST* blobs) {
<a name="l00323"></a>00323   C_OUTLINE_LIST outlines;
<a name="l00324"></a>00324   C_OUTLINE_IT ol_it = &amp;outlines;
<a name="l00325"></a>00325   <span class="comment">// Iterate the boxes to convert to outlines.</span>
<a name="l00326"></a>00326   <span class="keywordtype">int</span> nboxes = boxaGetCount(*boxes);
<a name="l00327"></a>00327   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nboxes; ++i) {
<a name="l00328"></a>00328     l_int32 x, y, width, height;
<a name="l00329"></a>00329     boxaGetBoxGeometry(*boxes, i, &amp;x, &amp;y, &amp;width, &amp;height);
<a name="l00330"></a>00330     <span class="comment">// Make a C_OUTLINE from the leptonica box. This is a bit of a hack,</span>
<a name="l00331"></a>00331     <span class="comment">// as there is no outline, just a bounding box, but with some very</span>
<a name="l00332"></a>00332     <span class="comment">// small changes to coutln.cpp, it works nicely.</span>
<a name="l00333"></a>00333     <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> top_left(x, y);
<a name="l00334"></a>00334     <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> bot_right(x + width, y + height);
<a name="l00335"></a>00335     <a class="code" href="class_c_r_a_c_k_e_d_g_e.html">CRACKEDGE</a> startpt;
<a name="l00336"></a>00336     startpt.<a class="code" href="class_c_r_a_c_k_e_d_g_e.html#ae7bcdb1f6f28f612a0ff4ace03b38165">pos</a> = top_left;
<a name="l00337"></a>00337     <a class="code" href="class_c___o_u_t_l_i_n_e.html">C_OUTLINE</a>* outline = <span class="keyword">new</span> <a class="code" href="coutln_8h.html#a33c25172cfe8e7ec617eb16413b61294">C_OUTLINE</a>(&amp;startpt, top_left, bot_right, 0);
<a name="l00338"></a>00338     ol_it.add_after_then_move(outline);
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340   <span class="comment">// Use outlines_to_blobs to convert the outlines to blobs and find</span>
<a name="l00341"></a>00341   <span class="comment">// overlapping and contained objects. The output list of blobs in the block</span>
<a name="l00342"></a>00342   <span class="comment">// has all the bad ones filtered out and deleted.</span>
<a name="l00343"></a>00343   <a class="code" href="class_b_l_o_c_k.html">BLOCK</a> block;
<a name="l00344"></a>00344   <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> page_tl(0, 0);
<a name="l00345"></a>00345   <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> page_br(image_width, image_height);
<a name="l00346"></a>00346   <a class="code" href="edgblob_8cpp.html#ae0cc26838f9973f097882b899b69b249">outlines_to_blobs</a>(&amp;block, page_tl, page_br, &amp;outlines);
<a name="l00347"></a>00347   <span class="comment">// Transfer the created blobs to the output list.</span>
<a name="l00348"></a>00348   C_BLOB_IT blob_it(blobs);
<a name="l00349"></a>00349   blob_it.add_list_after(block.<a class="code" href="class_b_l_o_c_k.html#a23196fe0d7230572b44aa77031a1d72a" title="get blobs">blob_list</a>());
<a name="l00350"></a>00350   <span class="comment">// The boxes aren&#39;t needed any more.</span>
<a name="l00351"></a>00351   boxaDestroy(boxes);
<a name="l00352"></a>00352 }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="comment">// Finds vertical line objects in pix_vline and removes the from src_pix.</span>
<a name="l00355"></a>00355 <span class="comment">// Uses the given resolution to determine size thresholds instead of any</span>
<a name="l00356"></a>00356 <span class="comment">// that may be present in the pix.</span>
<a name="l00357"></a>00357 <span class="comment">// The output vertical_x and vertical_y contain a sum of the output vectors,</span>
<a name="l00358"></a>00358 <span class="comment">// thereby giving the mean vertical direction.</span>
<a name="l00359"></a>00359 <span class="comment">// The output vectors are owned by the list and Frozen (cannot refit) by</span>
<a name="l00360"></a>00360 <span class="comment">// having no boxes, as there is no need to refit or merge separator lines.</span>
<a name="l00361"></a>00361 <span class="comment">// If no good lines are found, pix_vline is destroyed.</span>
<a name="l00362"></a>00362 <span class="comment">// None of the input pointers may be NULL, and if *pix_vline is NULL then</span>
<a name="l00363"></a>00363 <span class="comment">// the function does nothing.</span>
<a name="l00364"></a>00364 <span class="keywordtype">void</span> LineFinder::FindAndRemoveVLines(<span class="keywordtype">int</span> resolution,
<a name="l00365"></a>00365                                      Pix* pix_intersections,
<a name="l00366"></a>00366                                      <span class="keywordtype">int</span>* vertical_x, <span class="keywordtype">int</span>* vertical_y,
<a name="l00367"></a>00367                                      Pix** pix_vline, Pix* pix_non_vline,
<a name="l00368"></a>00368                                      Pix* src_pix, TabVector_LIST* vectors) {
<a name="l00369"></a>00369   <span class="keywordflow">if</span> (pix_vline == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || *pix_vline == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span>;
<a name="l00370"></a>00370   C_BLOB_LIST line_cblobs;
<a name="l00371"></a>00371   BLOBNBOX_LIST line_bblobs;
<a name="l00372"></a>00372   GetLineBoxes(<span class="keyword">false</span>, *pix_vline, pix_intersections,
<a name="l00373"></a>00373                &amp;line_cblobs, &amp;line_bblobs);
<a name="l00374"></a>00374   <span class="keywordtype">int</span> width = pixGetWidth(src_pix);
<a name="l00375"></a>00375   <span class="keywordtype">int</span> height = pixGetHeight(src_pix);
<a name="l00376"></a>00376   <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> bleft(0, 0);
<a name="l00377"></a>00377   <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> tright(width, height);
<a name="l00378"></a>00378   FindLineVectors(bleft, tright, &amp;line_bblobs, vertical_x, vertical_y, vectors);
<a name="l00379"></a>00379   <span class="keywordflow">if</span> (!vectors-&gt;empty()) {
<a name="l00380"></a>00380     RemoveUnusedLineSegments(<span class="keyword">false</span>, &amp;line_bblobs, *pix_vline);
<a name="l00381"></a>00381     SubtractLinesAndResidue(*pix_vline, pix_non_vline, resolution, src_pix);
<a name="l00382"></a>00382     <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> vertical;
<a name="l00383"></a>00383     vertical.<a class="code" href="class_i_c_o_o_r_d.html#a202dcd2920b28d85c2338d28dac8c5fe" title="Set from the given x,y, shrinking the vector to fit if needed.">set_with_shrink</a>(*vertical_x, *vertical_y);
<a name="l00384"></a>00384     <a class="code" href="classtesseract_1_1_tab_vector.html#a19795eab9036e3f6eb8a274d2c2b0179">TabVector::MergeSimilarTabVectors</a>(vertical, vectors, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00385"></a>00385   } <span class="keywordflow">else</span> {
<a name="l00386"></a>00386     pixDestroy(pix_vline);
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">// Finds horizontal line objects in pix_hline and removes them from src_pix.</span>
<a name="l00391"></a>00391 <span class="comment">// Uses the given resolution to determine size thresholds instead of any</span>
<a name="l00392"></a>00392 <span class="comment">// that may be present in the pix.</span>
<a name="l00393"></a>00393 <span class="comment">// The output vertical_x and vertical_y contain a sum of the output vectors,</span>
<a name="l00394"></a>00394 <span class="comment">// thereby giving the mean vertical direction.</span>
<a name="l00395"></a>00395 <span class="comment">// The output vectors are owned by the list and Frozen (cannot refit) by</span>
<a name="l00396"></a>00396 <span class="comment">// having no boxes, as there is no need to refit or merge separator lines.</span>
<a name="l00397"></a>00397 <span class="comment">// If no good lines are found, pix_hline is destroyed.</span>
<a name="l00398"></a>00398 <span class="comment">// None of the input pointers may be NULL, and if *pix_hline is NULL then</span>
<a name="l00399"></a>00399 <span class="comment">// the function does nothing.</span>
<a name="l00400"></a>00400 <span class="keywordtype">void</span> LineFinder::FindAndRemoveHLines(<span class="keywordtype">int</span> resolution,
<a name="l00401"></a>00401                                      Pix* pix_intersections,
<a name="l00402"></a>00402                                      <span class="keywordtype">int</span> vertical_x, <span class="keywordtype">int</span> vertical_y,
<a name="l00403"></a>00403                                      Pix** pix_hline, Pix* pix_non_hline,
<a name="l00404"></a>00404                                      Pix* src_pix, TabVector_LIST* vectors) {
<a name="l00405"></a>00405   <span class="keywordflow">if</span> (pix_hline == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || *pix_hline == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span>;
<a name="l00406"></a>00406   C_BLOB_LIST line_cblobs;
<a name="l00407"></a>00407   BLOBNBOX_LIST line_bblobs;
<a name="l00408"></a>00408   GetLineBoxes(<span class="keyword">true</span>, *pix_hline, pix_intersections, &amp;line_cblobs, &amp;line_bblobs);
<a name="l00409"></a>00409   <span class="keywordtype">int</span> width = pixGetWidth(src_pix);
<a name="l00410"></a>00410   <span class="keywordtype">int</span> height = pixGetHeight(src_pix);
<a name="l00411"></a>00411   <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> bleft(0, 0);
<a name="l00412"></a>00412   <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> tright(height, width);
<a name="l00413"></a>00413   FindLineVectors(bleft, tright, &amp;line_bblobs, &amp;vertical_x, &amp;vertical_y,
<a name="l00414"></a>00414                   vectors);
<a name="l00415"></a>00415   <span class="keywordflow">if</span> (!vectors-&gt;empty()) {
<a name="l00416"></a>00416     RemoveUnusedLineSegments(<span class="keyword">true</span>, &amp;line_bblobs, *pix_hline);
<a name="l00417"></a>00417     SubtractLinesAndResidue(*pix_hline, pix_non_hline, resolution, src_pix);
<a name="l00418"></a>00418     <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a> vertical;
<a name="l00419"></a>00419     vertical.<a class="code" href="class_i_c_o_o_r_d.html#a202dcd2920b28d85c2338d28dac8c5fe" title="Set from the given x,y, shrinking the vector to fit if needed.">set_with_shrink</a>(vertical_x, vertical_y);
<a name="l00420"></a>00420     <a class="code" href="classtesseract_1_1_tab_vector.html#a19795eab9036e3f6eb8a274d2c2b0179">TabVector::MergeSimilarTabVectors</a>(vertical, vectors, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00421"></a>00421     <span class="comment">// Iterate the vectors to flip them. x and y were flipped for horizontal</span>
<a name="l00422"></a>00422     <span class="comment">// lines, so FindLineVectors can work just with the vertical case.</span>
<a name="l00423"></a>00423     <span class="comment">// See GetLineBoxes for more on the flip.</span>
<a name="l00424"></a>00424     TabVector_IT h_it(vectors);
<a name="l00425"></a>00425     <span class="keywordflow">for</span> (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
<a name="l00426"></a>00426       h_it.data()-&gt;XYFlip();
<a name="l00427"></a>00427     }
<a name="l00428"></a>00428   } <span class="keywordflow">else</span> {
<a name="l00429"></a>00429     pixDestroy(pix_hline);
<a name="l00430"></a>00430   }
<a name="l00431"></a>00431 }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="comment">// Finds vertical lines in the given list of BLOBNBOXes. bleft and tright</span>
<a name="l00434"></a>00434 <span class="comment">// are the bounds of the image on which the input line_bblobs were found.</span>
<a name="l00435"></a>00435 <span class="comment">// The input line_bblobs list is const really.</span>
<a name="l00436"></a>00436 <span class="comment">// The output vertical_x and vertical_y are the total of all the vectors.</span>
<a name="l00437"></a>00437 <span class="comment">// The output list of TabVector makes no reference to the input BLOBNBOXes.</span>
<a name="l00438"></a>00438 <span class="keywordtype">void</span> LineFinder::FindLineVectors(<span class="keyword">const</span> <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a>&amp; bleft, <span class="keyword">const</span> <a class="code" href="class_i_c_o_o_r_d.html" title="integer coordinate">ICOORD</a>&amp; tright,
<a name="l00439"></a>00439                                  BLOBNBOX_LIST* line_bblobs,
<a name="l00440"></a>00440                                  <span class="keywordtype">int</span>* vertical_x, <span class="keywordtype">int</span>* vertical_y,
<a name="l00441"></a>00441                                  TabVector_LIST* vectors) {
<a name="l00442"></a>00442   BLOBNBOX_IT bbox_it(line_bblobs);
<a name="l00443"></a>00443   <span class="keywordtype">int</span> b_count = 0;
<a name="l00444"></a>00444   <span class="comment">// Put all the blobs into the grid to find the lines, and move the blobs</span>
<a name="l00445"></a>00445   <span class="comment">// to the output lists.</span>
<a name="l00446"></a>00446   AlignedBlob blob_grid(<a class="code" href="namespacetesseract.html#acbcf973384ce439c1b3ab4decf0c383c" title="Grid size used by line finder. Not very critical.">kLineFindGridSize</a>, bleft, tright);
<a name="l00447"></a>00447   <span class="keywordflow">for</span> (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
<a name="l00448"></a>00448     <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a>* bblob = bbox_it.data();
<a name="l00449"></a>00449     bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a098a0c7864a31569db4c32e32f54504c">set_left_tab_type</a>(<a class="code" href="blobbox_8h.html#a6d0b33e703e1291d0b60d4fe5a5e12ccad0945333210420da84a7617b5788f246">TT_MAYBE_ALIGNED</a>);
<a name="l00450"></a>00450     bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a37c2f715b4cb67ae8ec6a507dd029787">set_left_rule</a>(bleft.<a class="code" href="class_i_c_o_o_r_d.html#a59722a47c540007c58a539f0e35b3f33" title="access function">x</a>());
<a name="l00451"></a>00451     bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#ae90db382b3842419f291ae29dd7cd778">set_right_rule</a>(tright.<a class="code" href="class_i_c_o_o_r_d.html#a59722a47c540007c58a539f0e35b3f33" title="access function">x</a>());
<a name="l00452"></a>00452     bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#af1c12b91267640dc5634f8992f96cb1a">set_left_crossing_rule</a>(bleft.<a class="code" href="class_i_c_o_o_r_d.html#a59722a47c540007c58a539f0e35b3f33" title="access function">x</a>());
<a name="l00453"></a>00453     bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a234b1b56e0790a98a0c549a36580ca60">set_right_crossing_rule</a>(tright.<a class="code" href="class_i_c_o_o_r_d.html#a59722a47c540007c58a539f0e35b3f33" title="access function">x</a>());
<a name="l00454"></a>00454     blob_grid.InsertBBox(<span class="keyword">false</span>, <span class="keyword">true</span>, bblob);
<a name="l00455"></a>00455     ++b_count;
<a name="l00456"></a>00456   }
<a name="l00457"></a>00457   <span class="keywordflow">if</span> (b_count == 0)
<a name="l00458"></a>00458     <span class="keywordflow">return</span>;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   <span class="comment">// Search the entire grid, looking for vertical line vectors.</span>
<a name="l00461"></a>00461   <a class="code" href="namespacetesseract.html#a2681de132e11a73d6fc4f281b2750109">BlobGridSearch</a> lsearch(&amp;blob_grid);
<a name="l00462"></a>00462   <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a>* bbox;
<a name="l00463"></a>00463   TabVector_IT vector_it(vectors);
<a name="l00464"></a>00464   *vertical_x = 0;
<a name="l00465"></a>00465   *vertical_y = 1;
<a name="l00466"></a>00466   lsearch.StartFullSearch();
<a name="l00467"></a>00467   <span class="keywordflow">while</span> ((bbox = lsearch.NextFullSearch()) != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00468"></a>00468     <span class="keywordflow">if</span> (bbox-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a8b16d77deb75ed8aa2ff9d6be9462ec1">left_tab_type</a>() == <a class="code" href="blobbox_8h.html#a6d0b33e703e1291d0b60d4fe5a5e12ccad0945333210420da84a7617b5788f246">TT_MAYBE_ALIGNED</a>) {
<a name="l00469"></a>00469       <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; box = bbox-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a7b97b8bc16b1473a28f9c44011522f4e">bounding_box</a>();
<a name="l00470"></a>00470       <span class="keywordflow">if</span> (<a class="code" href="classtesseract_1_1_aligned_blob.html#a357ff9e1d9bac2b1d88fb0d335fa7f3e">AlignedBlob::WithinTestRegion</a>(2, box.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>(), box.<a class="code" href="class_t_b_o_x.html#a4451d237f1cd18c4982d63fe36a11fc3">bottom</a>()))
<a name="l00471"></a>00471         <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;Finding line vector starting at bbox (%d,%d)\n&quot;</span>,
<a name="l00472"></a>00472                 box.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>(), box.<a class="code" href="class_t_b_o_x.html#a4451d237f1cd18c4982d63fe36a11fc3">bottom</a>());
<a name="l00473"></a>00473       AlignedBlobParams align_params(*vertical_x, *vertical_y, box.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>());
<a name="l00474"></a>00474       TabVector* vector = blob_grid.FindVerticalAlignment(align_params, bbox,
<a name="l00475"></a>00475                                                           vertical_x,
<a name="l00476"></a>00476                                                           vertical_y);
<a name="l00477"></a>00477       <span class="keywordflow">if</span> (vector != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00478"></a>00478         vector-&gt;Freeze();
<a name="l00479"></a>00479         vector_it.add_to_end(vector);
<a name="l00480"></a>00480       }
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482   }
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="comment">// Returns a Pix music mask if music is detected.</span>
<a name="l00486"></a>00486 <span class="comment">// Any vertical line that has at least 5 intersections in sufficient density</span>
<a name="l00487"></a>00487 <span class="comment">// is taken to be a bar. Bars are used as a seed and the entire touching</span>
<a name="l00488"></a>00488 <span class="comment">// component is added to the output music mask and subtracted from the lines.</span>
<a name="l00489"></a>00489 <span class="comment">// Returns NULL and does minimal work if no music is found.</span>
<a name="l00490"></a>00490 <span class="keyword">static</span> Pix* FilterMusic(<span class="keywordtype">int</span> resolution, Pix* pix_closed,
<a name="l00491"></a>00491                         Pix* pix_vline, Pix* pix_hline,
<a name="l00492"></a>00492                         l_int32* v_empty, l_int32* h_empty) {
<a name="l00493"></a>00493   <span class="keywordtype">int</span> max_stave_height = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(resolution * <a class="code" href="namespacetesseract.html#a40e2e4747be3bc8a6358a023e2e3a001">kMaxStaveHeight</a>);
<a name="l00494"></a>00494   Pix* intersection_pix = pixAnd(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_vline, pix_hline);
<a name="l00495"></a>00495   Boxa* boxa = pixConnComp(pix_vline, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 8);
<a name="l00496"></a>00496   <span class="comment">// Iterate over the boxes to find music bars.</span>
<a name="l00497"></a>00497   <span class="keywordtype">int</span> nboxes = boxaGetCount(boxa);
<a name="l00498"></a>00498   Pix* music_mask = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00499"></a>00499   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nboxes; ++i) {
<a name="l00500"></a>00500     Box* box = boxaGetBox(boxa, i, L_CLONE);
<a name="l00501"></a>00501     l_int32 x, y, box_width, box_height;
<a name="l00502"></a>00502     boxGetGeometry(box, &amp;x, &amp;y, &amp;box_width, &amp;box_height);
<a name="l00503"></a>00503     <span class="keywordtype">int</span> joins = NumTouchingIntersections(box, intersection_pix);
<a name="l00504"></a>00504     <span class="comment">// Test for the join density being at least 5 per max_stave_height,</span>
<a name="l00505"></a>00505     <span class="comment">// ie (joins-1)/box_height &gt;= (5-1)/max_stave_height.</span>
<a name="l00506"></a>00506     <span class="keywordflow">if</span> (joins &gt;= 5 &amp;&amp; (joins - 1) * max_stave_height &gt;= 4 * box_height) {
<a name="l00507"></a>00507       <span class="comment">// This is a music bar. Add to the mask.</span>
<a name="l00508"></a>00508       <span class="keywordflow">if</span> (music_mask == <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00509"></a>00509         music_mask = pixCreate(pixGetWidth(pix_vline), pixGetHeight(pix_vline),
<a name="l00510"></a>00510                                1);
<a name="l00511"></a>00511       pixSetInRect(music_mask, box);
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513     boxDestroy(&amp;box);
<a name="l00514"></a>00514   }
<a name="l00515"></a>00515   boxaDestroy(&amp;boxa);
<a name="l00516"></a>00516   pixDestroy(&amp;intersection_pix);
<a name="l00517"></a>00517   <span class="keywordflow">if</span> (music_mask != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00518"></a>00518     <span class="comment">// The mask currently contains just the bars. Use the mask as a seed</span>
<a name="l00519"></a>00519     <span class="comment">// and the pix_closed as the mask for a seedfill to get all the</span>
<a name="l00520"></a>00520     <span class="comment">// intersecting staves.</span>
<a name="l00521"></a>00521     pixSeedfillBinary(music_mask, music_mask, pix_closed, 8);
<a name="l00522"></a>00522     <span class="comment">// Filter out false positives. CCs in the music_mask should be the vast</span>
<a name="l00523"></a>00523     <span class="comment">// majority of the pixels in their bounding boxes, as we expect just a</span>
<a name="l00524"></a>00524     <span class="comment">// tiny amount of text, a few phrase marks, and crescendo etc left.</span>
<a name="l00525"></a>00525     Boxa* boxa = pixConnComp(music_mask, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 8);
<a name="l00526"></a>00526     <span class="comment">// Iterate over the boxes to find music components.</span>
<a name="l00527"></a>00527     <span class="keywordtype">int</span> nboxes = boxaGetCount(boxa);
<a name="l00528"></a>00528     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nboxes; ++i) {
<a name="l00529"></a>00529       Box* box = boxaGetBox(boxa, i, L_CLONE);
<a name="l00530"></a>00530       Pix* rect_pix = pixClipRectangle(music_mask, box, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00531"></a>00531       l_int32 music_pixels;
<a name="l00532"></a>00532       pixCountPixels(rect_pix, &amp;music_pixels, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00533"></a>00533       pixDestroy(&amp;rect_pix);
<a name="l00534"></a>00534       rect_pix = pixClipRectangle(pix_closed, box, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00535"></a>00535       l_int32 all_pixels;
<a name="l00536"></a>00536       pixCountPixels(rect_pix, &amp;all_pixels, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00537"></a>00537       pixDestroy(&amp;rect_pix);
<a name="l00538"></a>00538       <span class="keywordflow">if</span> (music_pixels &lt; <a class="code" href="namespacetesseract.html#a064746ea8b34175e6f12ce364c8d6414">kMinMusicPixelFraction</a> * all_pixels) {
<a name="l00539"></a>00539         <span class="comment">// False positive. Delete from the music mask.</span>
<a name="l00540"></a>00540         pixClearInRect(music_mask, box);
<a name="l00541"></a>00541       }
<a name="l00542"></a>00542       boxDestroy(&amp;box);
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544     l_int32 no_remaining_music;
<a name="l00545"></a>00545     boxaDestroy(&amp;boxa);
<a name="l00546"></a>00546     pixZero(music_mask, &amp;no_remaining_music);
<a name="l00547"></a>00547     <span class="keywordflow">if</span> (no_remaining_music) {
<a name="l00548"></a>00548       pixDestroy(&amp;music_mask);
<a name="l00549"></a>00549     } <span class="keywordflow">else</span> {
<a name="l00550"></a>00550       pixSubtract(pix_vline, pix_vline, music_mask);
<a name="l00551"></a>00551       pixSubtract(pix_hline, pix_hline, music_mask);
<a name="l00552"></a>00552       <span class="comment">// We may have deleted all the lines</span>
<a name="l00553"></a>00553       pixZero(pix_vline, v_empty);
<a name="l00554"></a>00554       pixZero(pix_hline, h_empty);
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556   }
<a name="l00557"></a>00557   <span class="keywordflow">return</span> music_mask;
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560 <span class="comment">// Most of the heavy lifting of line finding. Given src_pix and its separate</span>
<a name="l00561"></a>00561 <span class="comment">// resolution, returns image masks:</span>
<a name="l00562"></a>00562 <span class="comment">// pix_vline           candidate vertical lines.</span>
<a name="l00563"></a>00563 <span class="comment">// pix_non_vline       pixels that didn&#39;t look like vertical lines.</span>
<a name="l00564"></a>00564 <span class="comment">// pix_hline           candidate horizontal lines.</span>
<a name="l00565"></a>00565 <span class="comment">// pix_non_hline       pixels that didn&#39;t look like horizontal lines.</span>
<a name="l00566"></a>00566 <span class="comment">// pix_intersections   pixels where vertical and horizontal lines meet.</span>
<a name="l00567"></a>00567 <span class="comment">// pix_music_mask      candidate music staves.</span>
<a name="l00568"></a>00568 <span class="comment">// This function promises to initialize all the output (2nd level) pointers,</span>
<a name="l00569"></a>00569 <span class="comment">// but any of the returns that are empty will be NULL on output.</span>
<a name="l00570"></a>00570 <span class="comment">// None of the input (1st level) pointers may be NULL except pix_music_mask,</span>
<a name="l00571"></a>00571 <span class="comment">// which will disable music detection, and pixa_display.</span>
<a name="l00572"></a>00572 <span class="keywordtype">void</span> LineFinder::GetLineMasks(<span class="keywordtype">int</span> resolution, Pix* src_pix,
<a name="l00573"></a>00573                               Pix** pix_vline, Pix** pix_non_vline,
<a name="l00574"></a>00574                               Pix** pix_hline, Pix** pix_non_hline,
<a name="l00575"></a>00575                               Pix** pix_intersections, Pix** pix_music_mask,
<a name="l00576"></a>00576                               Pixa* pixa_display) {
<a name="l00577"></a>00577   <span class="keywordtype">int</span> max_line_width = resolution / <a class="code" href="namespacetesseract.html#af5a3375be81da4b1d09d654fed77617a" title="Denominator of resolution makes max pixel width to allow thin lines.">kThinLineFraction</a>;
<a name="l00578"></a>00578   <span class="keywordtype">int</span> min_line_length = resolution / <a class="code" href="namespacetesseract.html#ab1ecce6329628c52853d15330697b9a5" title="Denominator of resolution makes min pixels to demand line lengths to be.">kMinLineLengthFraction</a>;
<a name="l00579"></a>00579   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00580"></a>00580     <a class="code" href="tprintf_8cpp.html#a0c2bcd4462ec67ab0971b34a0f610f55">tprintf</a>(<span class="stringliteral">&quot;Image resolution = %d, max line width = %d, min length=%d\n&quot;</span>,
<a name="l00581"></a>00581             resolution, max_line_width, min_line_length);
<a name="l00582"></a>00582   }
<a name="l00583"></a>00583   <span class="keywordtype">int</span> closing_brick = max_line_width / 3;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   <span class="comment">// Close up small holes, making it less likely that false alarms are found</span>
<a name="l00586"></a>00586   <span class="comment">// in thickened text (as it will become more solid) and also smoothing over</span>
<a name="l00587"></a>00587   <span class="comment">// some line breaks and nicks in the edges of the lines.</span>
<a name="l00588"></a>00588   Pix* pix_closed = pixCloseBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, src_pix, closing_brick, closing_brick);
<a name="l00589"></a>00589   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00590"></a>00590     pixaAddPix(pixa_display, pix_closed, L_CLONE);
<a name="l00591"></a>00591   <span class="comment">// Open up with a big box to detect solid areas, which can then be subtracted.</span>
<a name="l00592"></a>00592   <span class="comment">// This is very generous and will leave in even quite wide lines.</span>
<a name="l00593"></a>00593   Pix* pix_solid = pixOpenBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_closed, max_line_width,
<a name="l00594"></a>00594                                 max_line_width);
<a name="l00595"></a>00595   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00596"></a>00596     pixaAddPix(pixa_display, pix_solid, L_CLONE);
<a name="l00597"></a>00597   Pix* pix_hollow = pixSubtract(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_closed, pix_solid);
<a name="l00598"></a>00598   pixDestroy(&amp;pix_solid);
<a name="l00599"></a>00599   <span class="comment">// Now open up in both directions independently to find lines of at least</span>
<a name="l00600"></a>00600   <span class="comment">// 1 inch/kMinLineLengthFraction in length.</span>
<a name="l00601"></a>00601   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00602"></a>00602     pixaAddPix(pixa_display, pix_hollow, L_CLONE);
<a name="l00603"></a>00603   *pix_vline = pixOpenBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_hollow, 1, min_line_length);
<a name="l00604"></a>00604   *pix_hline = pixOpenBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_hollow, min_line_length, 1);
<a name="l00605"></a>00605   pixDestroy(&amp;pix_hollow);
<a name="l00606"></a>00606   <span class="comment">// Lines are sufficiently rare, that it is worth checking for a zero image.</span>
<a name="l00607"></a>00607   l_int32 v_empty = 0;
<a name="l00608"></a>00608   l_int32 h_empty = 0;
<a name="l00609"></a>00609   pixZero(*pix_vline, &amp;v_empty);
<a name="l00610"></a>00610   pixZero(*pix_hline, &amp;h_empty);
<a name="l00611"></a>00611   <span class="keywordflow">if</span> (pix_music_mask != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00612"></a>00612     <span class="keywordflow">if</span> (!v_empty &amp;&amp; !h_empty) {
<a name="l00613"></a>00613       *pix_music_mask = FilterMusic(resolution, pix_closed,
<a name="l00614"></a>00614                                     *pix_vline, *pix_hline,
<a name="l00615"></a>00615                                     &amp;v_empty, &amp;h_empty);
<a name="l00616"></a>00616     } <span class="keywordflow">else</span> {
<a name="l00617"></a>00617       *pix_music_mask = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00618"></a>00618     }
<a name="l00619"></a>00619   }
<a name="l00620"></a>00620   pixDestroy(&amp;pix_closed);
<a name="l00621"></a>00621   Pix* pix_nonlines = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00622"></a>00622   *pix_intersections = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00623"></a>00623   Pix* extra_non_hlines = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00624"></a>00624   <span class="keywordflow">if</span> (!v_empty) {
<a name="l00625"></a>00625     <span class="comment">// Subtract both line candidates from the source to get definite non-lines.</span>
<a name="l00626"></a>00626     pix_nonlines = pixSubtract(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, src_pix, *pix_vline);
<a name="l00627"></a>00627     <span class="keywordflow">if</span> (!h_empty) {
<a name="l00628"></a>00628       pixSubtract(pix_nonlines, pix_nonlines, *pix_hline);
<a name="l00629"></a>00629       <span class="comment">// Intersections are a useful indicator for likelihood of being a line.</span>
<a name="l00630"></a>00630       *pix_intersections = pixAnd(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, *pix_vline, *pix_hline);
<a name="l00631"></a>00631       <span class="comment">// Candidate vlines are not hlines (apart from the intersections)</span>
<a name="l00632"></a>00632       <span class="comment">// and vice versa.</span>
<a name="l00633"></a>00633       extra_non_hlines = pixSubtract(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, *pix_vline, *pix_intersections);
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635     *pix_non_vline = pixErodeBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_nonlines, <a class="code" href="namespacetesseract.html#ab97d7447e46667c618a568b97b96bb3c">kMaxLineResidue</a>, 1);
<a name="l00636"></a>00636     pixSeedfillBinary(*pix_non_vline, *pix_non_vline, pix_nonlines, 8);
<a name="l00637"></a>00637     <span class="keywordflow">if</span> (!h_empty) {
<a name="l00638"></a>00638       <span class="comment">// Candidate hlines are not vlines.</span>
<a name="l00639"></a>00639       pixOr(*pix_non_vline, *pix_non_vline, *pix_hline);
<a name="l00640"></a>00640       pixSubtract(*pix_non_vline, *pix_non_vline, *pix_intersections);
<a name="l00641"></a>00641     }
<a name="l00642"></a>00642     <span class="keywordflow">if</span> (!FilterFalsePositives(resolution, *pix_non_vline, *pix_intersections,
<a name="l00643"></a>00643                               *pix_vline))
<a name="l00644"></a>00644       pixDestroy(pix_vline);  <span class="comment">// No candidates left.</span>
<a name="l00645"></a>00645   } <span class="keywordflow">else</span> {
<a name="l00646"></a>00646     <span class="comment">// No vertical lines.</span>
<a name="l00647"></a>00647     pixDestroy(pix_vline);
<a name="l00648"></a>00648     *pix_non_vline = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00649"></a>00649     <span class="keywordflow">if</span> (!h_empty) {
<a name="l00650"></a>00650       pix_nonlines = pixSubtract(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, src_pix, *pix_hline);
<a name="l00651"></a>00651     }
<a name="l00652"></a>00652   }
<a name="l00653"></a>00653   <span class="keywordflow">if</span> (h_empty) {
<a name="l00654"></a>00654     pixDestroy(pix_hline);
<a name="l00655"></a>00655     *pix_non_hline = <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00656"></a>00656     <span class="keywordflow">if</span> (v_empty) {
<a name="l00657"></a>00657       <span class="keywordflow">return</span>;
<a name="l00658"></a>00658     }
<a name="l00659"></a>00659   } <span class="keywordflow">else</span> {
<a name="l00660"></a>00660     *pix_non_hline = pixErodeBrick(<a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, pix_nonlines, 1, <a class="code" href="namespacetesseract.html#ab97d7447e46667c618a568b97b96bb3c">kMaxLineResidue</a>);
<a name="l00661"></a>00661     pixSeedfillBinary(*pix_non_hline, *pix_non_hline, pix_nonlines, 8);
<a name="l00662"></a>00662     <span class="keywordflow">if</span> (extra_non_hlines != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00663"></a>00663       pixOr(*pix_non_hline, *pix_non_hline, extra_non_hlines);
<a name="l00664"></a>00664       pixDestroy(&amp;extra_non_hlines);
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666     <span class="keywordflow">if</span> (!FilterFalsePositives(resolution, *pix_non_hline, *pix_intersections,
<a name="l00667"></a>00667                               *pix_hline))
<a name="l00668"></a>00668       pixDestroy(pix_hline);  <span class="comment">// No candidates left.</span>
<a name="l00669"></a>00669   }
<a name="l00670"></a>00670   <span class="keywordflow">if</span> (pixa_display != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00671"></a>00671     <span class="keywordflow">if</span> (*pix_vline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) pixaAddPix(pixa_display, *pix_vline, L_CLONE);
<a name="l00672"></a>00672     <span class="keywordflow">if</span> (*pix_hline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) pixaAddPix(pixa_display, *pix_hline, L_CLONE);
<a name="l00673"></a>00673     <span class="keywordflow">if</span> (pix_nonlines != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) pixaAddPix(pixa_display, pix_nonlines, L_CLONE);
<a name="l00674"></a>00674     <span class="keywordflow">if</span> (*pix_non_vline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00675"></a>00675       pixaAddPix(pixa_display, *pix_non_vline, L_CLONE);
<a name="l00676"></a>00676     <span class="keywordflow">if</span> (*pix_non_hline != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00677"></a>00677       pixaAddPix(pixa_display, *pix_non_hline, L_CLONE);
<a name="l00678"></a>00678     <span class="keywordflow">if</span> (*pix_intersections != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00679"></a>00679       pixaAddPix(pixa_display, *pix_intersections, L_CLONE);
<a name="l00680"></a>00680     <span class="keywordflow">if</span> (pix_music_mask != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; *pix_music_mask != <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00681"></a>00681       pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
<a name="l00682"></a>00682   }
<a name="l00683"></a>00683   pixDestroy(&amp;pix_nonlines);
<a name="l00684"></a>00684 }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="comment">// Returns a list of boxes corresponding to the candidate line segments. Sets</span>
<a name="l00687"></a>00687 <span class="comment">// the line_crossings member of the boxes so we can later determin the number</span>
<a name="l00688"></a>00688 <span class="comment">// of intersections touched by a full line.</span>
<a name="l00689"></a>00689 <span class="keywordtype">void</span> LineFinder::GetLineBoxes(<span class="keywordtype">bool</span> horizontal_lines,
<a name="l00690"></a>00690                               Pix* pix_lines, Pix* pix_intersections,
<a name="l00691"></a>00691                               C_BLOB_LIST* line_cblobs,
<a name="l00692"></a>00692                               BLOBNBOX_LIST* line_bblobs) {
<a name="l00693"></a>00693   <span class="comment">// Put a single pixel crack in every line at an arbitrary spacing,</span>
<a name="l00694"></a>00694   <span class="comment">// so they break up and the bounding boxes can be used to get the</span>
<a name="l00695"></a>00695   <span class="comment">// direction accurately enough without needing outlines.</span>
<a name="l00696"></a>00696   <span class="keywordtype">int</span> wpl = pixGetWpl(pix_lines);
<a name="l00697"></a>00697   <span class="keywordtype">int</span> width = pixGetWidth(pix_lines);
<a name="l00698"></a>00698   <span class="keywordtype">int</span> height = pixGetHeight(pix_lines);
<a name="l00699"></a>00699   l_uint32* data = pixGetData(pix_lines);
<a name="l00700"></a>00700   <span class="keywordflow">if</span> (horizontal_lines) {
<a name="l00701"></a>00701     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; ++y, data += wpl) {
<a name="l00702"></a>00702       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = <a class="code" href="namespacetesseract.html#a67e1606288499ff9e08833b9c2a1ded8" title="Spacing of cracks across the page to break up tall vertical lines.">kCrackSpacing</a>; x &lt; width; x += <a class="code" href="namespacetesseract.html#a67e1606288499ff9e08833b9c2a1ded8" title="Spacing of cracks across the page to break up tall vertical lines.">kCrackSpacing</a>) {
<a name="l00703"></a>00703         CLEAR_DATA_BIT(data, x);
<a name="l00704"></a>00704       }
<a name="l00705"></a>00705     }
<a name="l00706"></a>00706   } <span class="keywordflow">else</span> {
<a name="l00707"></a>00707     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = <a class="code" href="namespacetesseract.html#a67e1606288499ff9e08833b9c2a1ded8" title="Spacing of cracks across the page to break up tall vertical lines.">kCrackSpacing</a>; y &lt; height; y += <a class="code" href="namespacetesseract.html#a67e1606288499ff9e08833b9c2a1ded8" title="Spacing of cracks across the page to break up tall vertical lines.">kCrackSpacing</a>) {
<a name="l00708"></a>00708       memset(data + wpl * y, 0, wpl * <span class="keyword">sizeof</span>(*data));
<a name="l00709"></a>00709     }
<a name="l00710"></a>00710   }
<a name="l00711"></a>00711   <span class="comment">// Get the individual connected components</span>
<a name="l00712"></a>00712   Boxa* boxa = pixConnComp(pix_lines, <a class="code" href="host_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 8);
<a name="l00713"></a>00713   <a class="code" href="classtesseract_1_1_line_finder.html#a9d00a88e3c4d6e1b9c7b28c3f6825b88">ConvertBoxaToBlobs</a>(width, height, &amp;boxa, line_cblobs);
<a name="l00714"></a>00714   <span class="comment">// Make the BLOBNBOXes from the C_BLOBs.</span>
<a name="l00715"></a>00715   C_BLOB_IT blob_it(line_cblobs);
<a name="l00716"></a>00716   BLOBNBOX_IT bbox_it(line_bblobs);
<a name="l00717"></a>00717   <span class="keywordflow">for</span> (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
<a name="l00718"></a>00718     <a class="code" href="class_c___b_l_o_b.html">C_BLOB</a>* cblob = blob_it.data();
<a name="l00719"></a>00719     <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a>* bblob = <span class="keyword">new</span> <a class="code" href="class_b_l_o_b_n_b_o_x.html">BLOBNBOX</a>(cblob);
<a name="l00720"></a>00720     bbox_it.add_to_end(bblob);
<a name="l00721"></a>00721     <span class="comment">// Determine whether the line segment touches two intersections.</span>
<a name="l00722"></a>00722     <span class="keyword">const</span> <a class="code" href="class_t_b_o_x.html">TBOX</a>&amp; bbox = bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a7b97b8bc16b1473a28f9c44011522f4e">bounding_box</a>();
<a name="l00723"></a>00723     Box* box = boxCreate(bbox.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>(), bbox.<a class="code" href="class_t_b_o_x.html#a4451d237f1cd18c4982d63fe36a11fc3">bottom</a>(),
<a name="l00724"></a>00724                          bbox.<a class="code" href="class_t_b_o_x.html#af95494a2ccacc70cc2b83820b2948619">width</a>(), bbox.<a class="code" href="class_t_b_o_x.html#a8379d4bbc72bdbb1f069fc14790e632d">height</a>());
<a name="l00725"></a>00725     bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a567e99fc9c08dfebbe144eb520c1322f">set_line_crossings</a>(NumTouchingIntersections(box, pix_intersections));
<a name="l00726"></a>00726     boxDestroy(&amp;box);
<a name="l00727"></a>00727     <span class="comment">// Transform the bounding box prior to finding lines. To save writing</span>
<a name="l00728"></a>00728     <span class="comment">// two line finders, flip x and y for horizontal lines and re-use the</span>
<a name="l00729"></a>00729     <span class="comment">// tab-stop detection code. For vertical lines we still have to flip the</span>
<a name="l00730"></a>00730     <span class="comment">// y-coordinates to switch from leptonica coords to tesseract coords.</span>
<a name="l00731"></a>00731     <span class="keywordflow">if</span> (horizontal_lines) {
<a name="l00732"></a>00732       <span class="comment">// Note that we have Leptonica coords stored in a Tesseract box, so that</span>
<a name="l00733"></a>00733       <span class="comment">// bbox.bottom(), being the MIN y coord, is actually the top, so to get</span>
<a name="l00734"></a>00734       <span class="comment">// back to Leptonica coords in RemoveUnusedLineSegments, we have to</span>
<a name="l00735"></a>00735       <span class="comment">// use height - box.right() as the top, which looks very odd.</span>
<a name="l00736"></a>00736       <a class="code" href="class_t_b_o_x.html">TBOX</a> new_box(height - bbox.<a class="code" href="class_t_b_o_x.html#adf92e9fdac1bdf11c10d1c4d1178791a">top</a>(), bbox.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>(),
<a name="l00737"></a>00737                    height - bbox.<a class="code" href="class_t_b_o_x.html#a4451d237f1cd18c4982d63fe36a11fc3">bottom</a>(), bbox.<a class="code" href="class_t_b_o_x.html#a8703081c1a1c26db3a4dddaca1028e34">right</a>());
<a name="l00738"></a>00738       bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a8f076c06c79a5d3637d2f2f3b03a1a85">set_bounding_box</a>(new_box);
<a name="l00739"></a>00739     } <span class="keywordflow">else</span> {
<a name="l00740"></a>00740       <a class="code" href="class_t_b_o_x.html">TBOX</a> new_box(bbox.<a class="code" href="class_t_b_o_x.html#a724fabf566586b663577dfa944ffbc61">left</a>(), height - bbox.<a class="code" href="class_t_b_o_x.html#adf92e9fdac1bdf11c10d1c4d1178791a">top</a>(),
<a name="l00741"></a>00741                    bbox.<a class="code" href="class_t_b_o_x.html#a8703081c1a1c26db3a4dddaca1028e34">right</a>(), height - bbox.<a class="code" href="class_t_b_o_x.html#a4451d237f1cd18c4982d63fe36a11fc3">bottom</a>());
<a name="l00742"></a>00742       bblob-&gt;<a class="code" href="class_b_l_o_b_n_b_o_x.html#a8f076c06c79a5d3637d2f2f3b03a1a85">set_bounding_box</a>(new_box);
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744   }
<a name="l00745"></a>00745 }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 }  <span class="comment">// namespace tesseract.</span>
<a name="l00748"></a>00748 
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="linefind_8cpp.html">linefind.cpp</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Fri Mar 30 2012 23:21:38 for Tesseract by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
